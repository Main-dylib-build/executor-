
#include "../../../ios_compat.h"
#include "VulnerabilityDetector.h"
#include <iostream>
#include <sstream>
#include <algorithm>
#include <cctype>
#include <regex>
#include <random>
#include <thread>
#include <future>
#include <unordered_set>
#include "../local_models/GeneralAssistantModel.h"

namespace iOS {
namespace AIFeatures {
namespace VulnerabilityDetection {

// Common suspicious function patterns for quick lookup
static const std::unordered_set<std::string> SUSPICIOUS_FUNCTIONS = {
    "loadstring", "httpget", "getfenv", "setfenv", "rawget", "rawset", 
    "getrawmetatable", "setrawmetatable", "newcclosure", "hookfunction",
    "fireclickdetector", "firetouchinterest", "sethiddenproperty"
};

// Map of vulnerability patterns with weighted scores
static const std::unordered_map<std::string, float> VULNERABILITY_PATTERNS = {
    // Remote control patterns
    {"admin", 0.7f},
    {"execute", 0.8f},
    {"command", 0.6f},
    {"run", 0.5f},
    {"give", 0.6f},
    {"set", 0.4f},
    {"change", 0.4f},
    {"modify", 0.5f},
    {"apply", 0.3f},
    {"teleport", 0.6f},
    
    // Script execution patterns
    {"loadstring", 0.9f},
    {"require", 0.4f},
    {"dofile", 0.8f},
    {"getfenv", 0.7f},
    {"setfenv", 0.8f},
    {"function", 0.3f},
    {"pcall", 0.5f},
    {"xpcall", 0.5f},
    {"spawn", 0.4f},
    {"coroutine", 0.4f},
    
    // Network patterns
    {"fireserver", 0.7f},
    {"invokeserver", 0.7f},
    {"remotefunction", 0.6f},
    {"remoteevent", 0.6f},
    {"bindablefunction", 0.5f},
    {"bindableevent", 0.5f},
    
    // Bypassing patterns
    {"string.char", 0.7f},
    {"string.byte", 0.7f},
    {"string.sub", 0.6f},
    {"string.gsub", 0.7f},
    {"string.format", 0.5f},
    {"table.concat", 0.5f}
};

// Cache of scanned objects and analyzed scripts for performance
static std::unordered_map<std::string, float> g_objectVulnerabilityScores;
static std::unordered_map<std::string, std::string> g_exploitCodeCache;
static std::mutex g_cacheMutex;

// Constructor with enhanced initialization
VulnerabilityDetector::VulnerabilityDetector()
    : m_gameRoot(nullptr),
      m_isScanning(false),
      m_isInitialized(false) {
    
    // Clear caches
    std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
    g_objectVulnerabilityScores.clear();
    g_exploitCodeCache.clear();
}

// Destructor with enhanced cleanup
VulnerabilityDetector::~VulnerabilityDetector() {
    // Cancel any active scan
    CancelScan();
    
    // Save vulnerability database
    if (m_isInitialized) {
        SaveVulnerabilityDatabase();
    }
    
    // Clear caches
    std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
    g_objectVulnerabilityScores.clear();
    g_exploitCodeCache.clear();
}

// Initialize the vulnerability detector with enhanced caching
bool VulnerabilityDetector::Initialize(const std::string& modelPath) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (m_isInitialized) {
        return true;
    }
    
    try {
        // Create directory if it doesn't exist
        NSString* dirPath = [NSString stringWithUTF8String:modelPath.c_str()];
        NSFileManager* fileManager = [NSFileManager defaultManager];
        
        if (![fileManager fileExistsAtPath:dirPath]) {
            NSError* error = nil;
            BOOL success = [fileManager createDirectoryAtPath:dirPath
                                  withIntermediateDirectories:YES
                                                   attributes:nil
                                                        error:&error];
            if (!success) {
                std::cerr << "Failed to create vulnerability detector directory: " 
                         << [[error localizedDescription] UTF8String] << std::endl;
                return false;
            }
        }
        
        // Initialize models
        bool modelsInitialized = InitializeModels();
        if (!modelsInitialized) {
            std::cerr << "Failed to initialize vulnerability detection models" << std::endl;
            return false;
        }
        
        // Load vulnerability database
        bool databaseLoaded = LoadVulnerabilityDatabase();
        if (!databaseLoaded) {
            std::cout << "No existing vulnerability database found, starting fresh" << std::endl;
        }
        
        // Pre-warm the cache with common patterns
        std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
        for (const auto& pattern : VULNERABILITY_PATTERNS) {
            g_objectVulnerabilityScores[pattern.first] = pattern.second;
        }
        
        m_isInitialized = true;
        return true;
    } catch (const std::exception& e) {
        std::cerr << "Exception during vulnerability detector initialization: " << e.what() << std::endl;
        return false;
    }
}

// Initialize models with enhanced functionality
bool VulnerabilityDetector::InitializeModels() {
    // These models will be trained locally with data collected during gameplay
    
    // Remote event analysis model - enhanced version
    m_remoteEventModel = std::make_shared<LocalModels::VulnerabilityDetectionModel>();
    dynamic_cast<LocalModels::VulnerabilityDetectionModel*>(m_remoteEventModel.get())->EnableAllVulnerabilityTypes();
    m_remoteEventModel->SetName("RemoteEventAnalysis");
    m_remoteEventModel->SetDescription("Advanced model for detecting vulnerable remote events");
    m_remoteEventModel->SetModelType("vulnerability_detection");
    
    // Script analysis model - enhanced version
    m_scriptAnalysisModel = std::make_shared<LocalModels::VulnerabilityDetectionModel>();
    dynamic_cast<LocalModels::VulnerabilityDetectionModel*>(m_scriptAnalysisModel.get())->EnableAllVulnerabilityTypes();
    m_scriptAnalysisModel->SetName("ScriptAnalysis");
    m_scriptAnalysisModel->SetDescription("Advanced model for detecting vulnerable scripts");
    m_scriptAnalysisModel->SetModelType("vulnerability_detection");
    
    // Network analysis model - enhanced version
    m_networkAnalysisModel = std::make_shared<LocalModels::VulnerabilityDetectionModel>();
    dynamic_cast<LocalModels::VulnerabilityDetectionModel*>(m_networkAnalysisModel.get())->EnableAllVulnerabilityTypes();
    m_networkAnalysisModel->SetName("NetworkAnalysis");
    m_networkAnalysisModel->SetDescription("Advanced model for detecting network vulnerabilities");
    m_networkAnalysisModel->SetModelType("vulnerability_detection");
    
    // Train models with default patterns if no training data exists
    try {
        // Add initial training data based on known vulnerability patterns
        std::unordered_map<std::string, std::vector<std::pair<std::string, float>>> initialTrainingData;
        
        // Add remote event patterns
        std::vector<std::pair<std::string, float>> remoteEventPatterns;
        for (const auto& pattern : VULNERABILITY_PATTERNS) {
            if (pattern.first.find("admin") != std::string::npos ||
                pattern.first.find("execute") != std::string::npos ||
                pattern.first.find("command") != std::string::npos) {
                remoteEventPatterns.push_back({pattern.first, pattern.second});
            }
        }
        initialTrainingData["RemoteEventAnalysis"] = remoteEventPatterns;
        
        // Add script patterns
        std::vector<std::pair<std::string, float>> scriptPatterns;
        for (const auto& pattern : VULNERABILITY_PATTERNS) {
            if (pattern.first.find("string") != std::string::npos ||
                pattern.first.find("loadstring") != std::string::npos ||
                pattern.first.find("getfenv") != std::string::npos) {
                scriptPatterns.push_back({pattern.first, pattern.second});
            }
        }
        initialTrainingData["ScriptAnalysis"] = scriptPatterns;
        
        // Add network patterns
        std::vector<std::pair<std::string, float>> networkPatterns;
        for (const auto& pattern : VULNERABILITY_PATTERNS) {
            if (pattern.first.find("fireserver") != std::string::npos ||
                pattern.first.find("invokeserver") != std::string::npos ||
                pattern.first.find("remote") != std::string::npos) {
                networkPatterns.push_back({pattern.first, pattern.second});
            }
        }
        initialTrainingData["NetworkAnalysis"] = networkPatterns;
        
        // Train initial models
        for (const auto& trainingData : initialTrainingData) {
            if (trainingData.first == "RemoteEventAnalysis" && m_remoteEventModel) {
                for (const auto& pattern : trainingData.second) {
                    m_remoteEventModel->AddTrainingExample(pattern.first, pattern.second > 0.6f ? "vulnerable" : "safe");
                }
                m_remoteEventModel->Train();
            }
            else if (trainingData.first == "ScriptAnalysis" && m_scriptAnalysisModel) {
                for (const auto& pattern : trainingData.second) {
                    m_scriptAnalysisModel->AddTrainingExample(pattern.first, pattern.second > 0.6f ? "vulnerable" : "safe");
                }
                m_scriptAnalysisModel->Train();
            }
            else if (trainingData.first == "NetworkAnalysis" && m_networkAnalysisModel) {
                for (const auto& pattern : trainingData.second) {
                    m_networkAnalysisModel->AddTrainingExample(pattern.first, pattern.second > 0.6f ? "vulnerable" : "safe");
                }
                m_networkAnalysisModel->Train();
            }
        }
    }
    catch (const std::exception& e) {
        std::cerr << "Warning: Exception during model training: " << e.what() << std::endl;
        // Continue initialization even if training fails
    }
    
    return true;
}

// Helper method to collect all game objects for better parallel processing
void VulnerabilityDetector::CollectGameObjects(
    const std::shared_ptr<GameObject>& root,
    std::vector<std::shared_ptr<GameObject>>& objects) {
    
    if (!root) return;
    
    // Add this object
    objects.push_back(root);
    
    // Add all children
    for (const auto& child : root->m_children) {
        CollectGameObjects(child, objects);
    }
}

// Analyze a single game object for vulnerabilities 
void VulnerabilityDetector::AnalyzeGameObject(
    const std::shared_ptr<GameObject>& gameObject,
    std::vector<Vulnerability>& results) {
    
    // Check if scan was cancelled
    if (!m_isScanning) {
        return;
    }
    
    // Check object type and analyze accordingly
    if (gameObject->m_className == "RemoteEvent") {
        AnalyzeRemoteEvent(gameObject, results);
    } else if (gameObject->m_className == "RemoteFunction") {
        AnalyzeRemoteFunction(gameObject, results);
    } else if (gameObject->m_className == "Script" || 
              gameObject->m_className == "LocalScript" ||
              gameObject->m_className == "ModuleScript") {
        // Get script source code
        std::string code = "";
        auto it = gameObject->m_properties.find("Source");
        if (it != gameObject->m_properties.end()) {
            code = it->second;
        }
        
        AnalyzeScript(gameObject, code, results);
    } else if (gameObject->m_className == "Part" ||
              gameObject->m_className == "MeshPart" ||
              gameObject->m_className == "Union") {
        CheckNetworkOwnership(gameObject, results);
    } else if (gameObject->m_className == "ServerStorage" ||
               gameObject->m_className == "ServerScriptService") {
        AnalyzeServerStorage(gameObject, results);
    } else if (gameObject->m_className == "ClickDetector" ||
               gameObject->m_className == "ProximityPrompt") {
        AnalyzeInteractiveObject(gameObject, results);
    }
}

// Helper to correlate vulnerabilities and find relationships
void VulnerabilityDetector::CorrelateVulnerabilities(ScanResult& result) {
    // Don't process if there are too few vulnerabilities to correlate
    if (result.m_vulnerabilities.size() < 2) return;
    
    // Group vulnerabilities by type
    std::unordered_map<VulnerabilityType, std::vector<Vulnerability*>> vulnerabilitiesByType;
    
    for (auto& vuln : result.m_vulnerabilities) {
        vulnerabilitiesByType[vuln.m_type].push_back(&vuln);
    }
    
    // Look for remote events that are used in scripts
    if (vulnerabilitiesByType.count(VulnerabilityType::RemoteEvent) && 
        vulnerabilitiesByType.count(VulnerabilityType::SecurityBypass)) {
        
        for (auto* remoteEvent : vulnerabilitiesByType[VulnerabilityType::RemoteEvent]) {
            for (auto* scriptVuln : vulnerabilitiesByType[VulnerabilityType::SecurityBypass]) {
                // Check if the script references this remote event
                if (scriptVuln->m_exploitCode.find(remoteEvent->m_name) != std::string::npos) {
                    // Increase severity and reliability for both
                    remoteEvent->m_severity = std::min(remoteEvent->m_severity + 0.1f, 1.0f);
                    remoteEvent->m_reliability = std::min(remoteEvent->m_reliability + 0.1f, 1.0f);
                    scriptVuln->m_severity = std::min(scriptVuln->m_severity + 0.1f, 1.0f);
                    scriptVuln->m_reliability = std::min(scriptVuln->m_reliability + 0.1f, 1.0f);
                    
                    // Add correlation metadata
                    remoteEvent->m_metadata["correlatedWith"] = scriptVuln->m_id;
                    scriptVuln->m_metadata["correlatedWith"] = remoteEvent->m_id;
                    
                    // Add correlation tags
                    remoteEvent->m_tags.push_back("CorrelatedWithScript");
                    scriptVuln->m_tags.push_back("CorrelatedWithRemoteEvent");
                }
            }
        }
    }
}

// New method to analyze server storage for accessible objects
bool VulnerabilityDetector::AnalyzeServerStorage(
    const std::shared_ptr<GameObject>& serverStorage, 
    std::vector<Vulnerability>& results) {
    
    bool foundVulnerabilities = false;
    
    // Check if server storage has suspicious children
    for (const auto& child : serverStorage->m_children) {
        // Look for scripts in server storage that might be accessible
        if (child->m_className == "Script" || 
            child->m_className == "ModuleScript") {
            // Create vulnerability
            Vulnerability vulnerability;
            vulnerability.m_id = GenerateVulnerabilityId();
            vulnerability.m_name = "Potentially accessible server storage item: " + child->m_name;
            vulnerability.m_description = "This item in ServerStorage might be accessible from client scripts.";
            vulnerability.m_type = VulnerabilityType::ServerStorage;
            vulnerability.m_path = child->m_path;
            vulnerability.m_severity = 0.6f;
            vulnerability.m_reliability = 0.5f;
            vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::system_clock::now().time_since_epoch()).count();
            vulnerability.m_verified = false;
            vulnerability.m_tags = {"ServerStorage", "AccessibleScript"};
            
            // Generate simple exploit code
            vulnerability.m_exploitCode = "-- Try to access server storage script\n"
                                         "local success, result = pcall(function()\n"
                                         "    return game:GetService('ServerStorage'):" + child->m_path + "\n"
                                         "end)\n"
                                         "if success then\n"
                                         "    print('Successfully accessed server storage item')\n"
                                         "end";
            
            results.push_back(vulnerability);
            foundVulnerabilities = true;
        }
    }
    
    return foundVulnerabilities;
}

// New method to analyze interactive objects like ClickDetectors
bool VulnerabilityDetector::AnalyzeInteractiveObject(
    const std::shared_ptr<GameObject>& interactiveObject,
    std::vector<Vulnerability>& results) {
    
    bool foundVulnerabilities = false;
    
    // Check if this is a ClickDetector with potential vulnerability
    if (interactiveObject->m_className == "ClickDetector") {
        // Create vulnerability
        Vulnerability vulnerability;
        vulnerability.m_id = GenerateVulnerabilityId();
        vulnerability.m_name = "Potentially vulnerable ClickDetector: " + interactiveObject->m_name;
        vulnerability.m_description = "This ClickDetector might be exploitable via FireClickDetector.";
        vulnerability.m_type = VulnerabilityType::GameSpecific;
        vulnerability.m_path = interactiveObject->m_path;
        vulnerability.m_severity = 0.5f;
        vulnerability.m_reliability = 0.5f;
        vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        vulnerability.m_verified = false;
        vulnerability.m_tags = {"ClickDetector", "Interactive"};
        
        // Generate exploit code
        vulnerability.m_exploitCode = "-- Attempt to fire click detector\n"
                                     "local detector = " + interactiveObject->m_path + "\n"
                                     "if detector then\n"
                                     "    fireclickdetector(detector)\n"
                                     "end";
        
        results.push_back(vulnerability);
        foundVulnerabilities = true;
    }
    
    return foundVulnerabilities;
}

// Start scanning a game with enhanced multi-threading
bool VulnerabilityDetector::StartScan(
    const std::string& gameId,
    const std::string& gameName,
    std::shared_ptr<GameObject> gameRoot,
    ScanProgressCallback progressCallback,
    ScanCompleteCallback completeCallback) {
    
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (!m_isInitialized) {
        std::cerr << "VulnerabilityDetector: Not initialized" << std::endl;
        return false;
    }
    
    if (m_isScanning) {
        std::cerr << "VulnerabilityDetector: Scan already in progress" << std::endl;
        return false;
    }
    
    if (!gameRoot) {
        std::cerr << "VulnerabilityDetector: No game root provided" << std::endl;
        return false;
    }
    
    // Set current game info
    m_currentGameId = gameId;
    m_currentGameName = gameName;
    m_gameRoot = gameRoot;
    
    // Set callbacks
    m_progressCallback = progressCallback;
    m_completeCallback = completeCallback;
    
    // Reset scan progress
    m_currentScanProgress = ScanProgress();
    m_currentScanProgress.m_isActive = true;
    
    // Clear caches for a fresh scan
    {
        std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
        g_exploitCodeCache.clear();
    }
    
    // Start scan in background thread
    m_isScanning = true;
    std::thread scanThread([this, gameId, gameName, gameRoot]() {
        // Create scan result
        ScanResult result;
        result.m_gameId = gameId;
        result.m_gameName = gameName;
        result.m_scanTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        
        try {
            // Start timer
            auto startTime = std::chrono::high_resolution_clock::now();
            
            // Update progress
            UpdateScanProgress(0.0f, "Starting scan", 0);
            
            // Collect all objects first for better parallel processing
            std::vector<std::shared_ptr<GameObject>> allObjects;
            CollectGameObjects(gameRoot, allObjects);
            
            // Update progress
            UpdateScanProgress(0.1f, "Collected " + std::to_string(allObjects.size()) + " objects for analysis", 0);
            
            // Process objects in batches for better performance
            const size_t BATCH_SIZE = 100;
            size_t totalBatches = (allObjects.size() + BATCH_SIZE - 1) / BATCH_SIZE;
            std::vector<std::future<std::vector<Vulnerability>>> futures;
            
            for (size_t batch = 0; batch < totalBatches && m_isScanning; ++batch) {
                size_t startIdx = batch * BATCH_SIZE;
                size_t endIdx = std::min(startIdx + BATCH_SIZE, allObjects.size());
                
                // Launch a task to process this batch
                futures.push_back(std::async(std::launch::async, [this, &allObjects, startIdx, endIdx]() {
                    std::vector<Vulnerability> batchResults;
                    for (size_t i = startIdx; i < endIdx && m_isScanning; ++i) {
                        // Analyze this object
                        AnalyzeGameObject(allObjects[i], batchResults);
                    }
                    return batchResults;
                }));
                
                // Update progress
                float progress = 0.1f + 0.8f * (float)batch / totalBatches;
                UpdateScanProgress(progress, "Processing batch " + std::to_string(batch+1) + 
                                  " of " + std::to_string(totalBatches), result.m_vulnerabilities.size());
            }
            
            // Collect results from all batches
            for (auto& future : futures) {
                if (!m_isScanning) break;
                
                std::vector<Vulnerability> batchResults = future.get();
                for (const auto& vulnerability : batchResults) {
                    result.m_vulnerabilities.push_back(vulnerability);
                    
                    // Call detected callback if registered
                    if (m_detectedCallback) {
                        m_detectedCallback(vulnerability);
                    }
                }
            }
            
            // Post-process to find relationships between vulnerabilities
            if (m_isScanning) {
                CorrelateVulnerabilities(result);
                UpdateScanProgress(0.95f, "Correlating vulnerabilities", result.m_vulnerabilities.size());
            }
            
            // End timer
            auto endTime = std::chrono::high_resolution_clock::now();
            result.m_scanDuration = std::chrono::duration_cast<std::chrono::milliseconds>(
                endTime - startTime).count();
            
            // Mark as complete if not cancelled
            result.m_scanComplete = m_isScanning;
            
            // Update progress
            UpdateScanProgress(1.0f, "Scan complete. Found " + std::to_string(result.m_vulnerabilities.size()) + 
                               " vulnerabilities", result.m_vulnerabilities.size());
            
            // Add to scan history
            {
                std::lock_guard<std::mutex> lock(m_mutex);
                m_scanHistory[gameId] = result;
                
                // Add to known vulnerabilities
                for (const auto& vulnerability : result.m_vulnerabilities) {
                    if (!IsKnownVulnerability(vulnerability)) {
                        m_knownVulnerabilities.push_back(vulnerability);
                    }
                }
            }
            
            // Call complete callback
            if (m_completeCallback) {
                m_completeCallback(result);
            }
            
            // Update models with new data
            TrainModelsWithDetectionHistory();
            
            // Save vulnerability database
            SaveVulnerabilityDatabase();
        } catch (const std::exception& e) {
            // Handle exception
            result.m_scanComplete = false;
            result.m_errorMessage = e.what();
            
            std::cerr << "Exception during vulnerability scan: " << e.what() << std::endl;
            
            // Call complete callback with error
            if (m_completeCallback && m_isScanning) {
                m_completeCallback(result);
            }
        }
        
        // Mark scan as complete
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            m_isScanning = false;
            m_currentScanProgress.m_isActive = false;
        }
    });
    
    // Detach thread to let it run independently
    scanThread.detach();
    
    return true;
}

// Cancel the current scan
bool VulnerabilityDetector::CancelScan() {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (!m_isScanning) {
        return false;
    }
    
    // Set scanning flag to false
    // The scan thread will check this and exit
    m_isScanning = false;
    m_currentScanProgress.m_isActive = false;
    
    return true;
}

// Get the current scan progress
VulnerabilityDetector::ScanProgress VulnerabilityDetector::GetScanProgress() {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_currentScanProgress;
}

// Check if a scan is in progress
bool VulnerabilityDetector::IsScanning() const {
    return m_isScanning;
}

// Get scan history
std::unordered_map<std::string, VulnerabilityDetector::ScanResult> VulnerabilityDetector::GetScanHistory() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_scanHistory;
}

// Get a specific scan result
VulnerabilityDetector::ScanResult VulnerabilityDetector::GetScanResult(const std::string& gameId) const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_scanHistory.find(gameId);
    if (it != m_scanHistory.end()) {
        return it->second;
    }
    
    // Return empty result if not found
    return ScanResult();
}

// Get all known vulnerabilities
std::vector<VulnerabilityDetector::Vulnerability> VulnerabilityDetector::GetKnownVulnerabilities() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_knownVulnerabilities;
}

// Get vulnerabilities by type
std::vector<VulnerabilityDetector::Vulnerability> VulnerabilityDetector::GetVulnerabilitiesByType(VulnerabilityType type) const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    std::vector<Vulnerability> result;
    
    for (const auto& vulnerability : m_knownVulnerabilities) {
        if (vulnerability.m_type == type) {
            result.push_back(vulnerability);
        }
    }
    
    return result;
}

// Get vulnerabilities by game
std::vector<VulnerabilityDetector::Vulnerability> VulnerabilityDetector::GetVulnerabilitiesByGame(const std::string& gameId) const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // Check if we have a scan result for this game
    auto it = m_scanHistory.find(gameId);
    if (it != m_scanHistory.end()) {
        return it->second.m_vulnerabilities;
    }
    
    // Return empty vector if not found
    return std::vector<Vulnerability>();
}

// Set vulnerability detected callback
void VulnerabilityDetector::SetVulnerabilityDetectedCallback(VulnerabilityDetectedCallback callback) {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_detectedCallback = callback;
}

// Add a manually discovered vulnerability
bool VulnerabilityDetector::AddVulnerability(const Vulnerability& vulnerability) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // Check if this is a known vulnerability
    if (IsKnownVulnerability(vulnerability)) {
        return false;
    }
    
    // Add to known vulnerabilities
    m_knownVulnerabilities.push_back(vulnerability);
    
    // Call detected callback
    if (m_detectedCallback) {
        m_detectedCallback(vulnerability);
    }
    
    // Save vulnerability database
    SaveVulnerabilityDatabase();
    
    return true;
}

// Report vulnerability exploit attempt
bool VulnerabilityDetector::ReportExploitAttempt(const std::string& vulnerabilityId, 
                                            bool success,
                                            const std::string& feedback) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // Find vulnerability
    for (auto& vulnerability : m_knownVulnerabilities) {
        if (vulnerability.m_id == vulnerabilityId) {
            // Update reliability based on success
            if (success) {
                vulnerability.m_reliability = std::min(vulnerability.m_reliability + 0.1f, 1.0f);
                vulnerability.m_verified = true;
            } else {
                vulnerability.m_reliability = std::max(vulnerability.m_reliability - 0.1f, 0.0f);
            }
            
            // Add feedback to metadata
            if (!feedback.empty()) {
                vulnerability.m_metadata["feedback"] = feedback;
            }
            
            // Save vulnerability database
            SaveVulnerabilityDatabase();
            
            return true;
        }
    }
    
    return false;
}

// Check game for server-side execution vulnerabilities
std::vector<VulnerabilityDetector::Vulnerability> VulnerabilityDetector::CheckForServerSideExecution(const std::string& gameId) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    std::vector<Vulnerability> results;
    
    // Get scan result for this game
    auto it = m_scanHistory.find(gameId);
    if (it == m_scanHistory.end()) {
        return results;
    }
    
    // Look for server-side execution vulnerabilities
    for (const auto& vulnerability : it->second.m_vulnerabilities) {
        if (vulnerability.m_type == VulnerabilityType::RemoteEvent ||
            vulnerability.m_type == VulnerabilityType::RemoteFunction ||
            vulnerability.m_type == VulnerabilityType::BackdoorScript ||
            vulnerability.m_type == VulnerabilityType::SecurityBypass) {
            results.push_back(vulnerability);
        }
    }
    
    return results;
}

// Analyze network traffic for vulnerabilities
std::vector<VulnerabilityDetector::Vulnerability> VulnerabilityDetector::AnalyzeNetworkTraffic(
    const std::string& gameId,
    const std::vector<uint8_t>& packetData) {
    
    std::lock_guard<std::mutex> lock(m_mutex);
    
    std::vector<Vulnerability> results;
    
    // In a real implementation, this would perform traffic analysis
    // using the network analysis model
    
    return results;
}

// Train the detection models
bool VulnerabilityDetector::TrainModels() {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // Train with detection history
    return TrainModelsWithDetectionHistory();
}

// Scan game object
void VulnerabilityDetector::ScanGameObject(const std::shared_ptr<GameObject>& gameObject, ScanResult& result) {
    // Check if scan was cancelled
    if (!m_isScanning) {
        return;
    }
    
    // Check if this is a potential vulnerability
    if (gameObject->m_className == "RemoteEvent") {
        AnalyzeRemoteEvent(gameObject, result);
    } else if (gameObject->m_className == "RemoteFunction") {
        AnalyzeRemoteFunction(gameObject, result);
    } else if (gameObject->m_className == "Script" || 
              gameObject->m_className == "LocalScript" ||
              gameObject->m_className == "ModuleScript") {
        // Get script source code
        std::string code = "";
        auto it = gameObject->m_properties.find("Source");
        if (it != gameObject->m_properties.end()) {
            code = it->second;
        }
        
        AnalyzeScript(gameObject, code, result);
    } else if (gameObject->m_className == "Part" ||
              gameObject->m_className == "MeshPart" ||
              gameObject->m_className == "Union") {
        CheckNetworkOwnership(gameObject, result);
    }
    
    // Recursively scan children
    size_t totalObjects = gameObject->m_children.size();
    for (size_t i = 0; i < totalObjects; ++i) {
        // Check if scan was cancelled
        if (!m_isScanning) {
            return;
        }
        
        // Scan child object
        ScanGameObject(gameObject->m_children[i], result);
        
        // Update progress
        float progress = (float)i / totalObjects;
        UpdateScanProgress(progress, "Scanning " + gameObject->m_children[i]->m_className + " objects", 
                          result.m_vulnerabilities.size());
    }
}

// Analyze remote event with enhanced weighted scoring
bool VulnerabilityDetector::AnalyzeRemoteEvent(const std::shared_ptr<GameObject>& remoteEvent, std::vector<Vulnerability>& results) {
    // First check the cache to avoid redundant analysis
    std::string cacheKey = "RemoteEvent:" + remoteEvent->m_path;
    {
        std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
        auto scoreIt = g_objectVulnerabilityScores.find(cacheKey);
        if (scoreIt != g_objectVulnerabilityScores.end() && scoreIt->second >= 0.5f) {
            // Create vulnerability from cache
            Vulnerability vulnerability;
            vulnerability.m_id = GenerateVulnerabilityId();
            vulnerability.m_name = "Cached vulnerable RemoteEvent: " + remoteEvent->m_name;
            vulnerability.m_description = "This RemoteEvent was previously identified as potentially vulnerable.";
            vulnerability.m_type = VulnerabilityType::RemoteEvent;
            vulnerability.m_path = remoteEvent->m_path;
            vulnerability.m_severity = scoreIt->second;
            vulnerability.m_reliability = 0.6f; // Slightly lower reliability for cached results
            vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::system_clock::now().time_since_epoch()).count();
            vulnerability.m_verified = false;
            vulnerability.m_tags = {"RemoteEvent", "Suspicious", "Cached"};
            
            // Generate exploit code
            auto exploitIt = g_exploitCodeCache.find(cacheKey);
            if (exploitIt != g_exploitCodeCache.end()) {
                vulnerability.m_exploitCode = exploitIt->second;
            } else {
                vulnerability.m_exploitCode = "-- Attempt to use the vulnerable RemoteEvent\n"
                                            "local event = game:GetService('ReplicatedStorage'):" + remoteEvent->m_path + "\n"
                                            "if event then\n"
                                            "    event:FireServer('admin', true) -- Try with admin privileges\n"
                                            "end";
                g_exploitCodeCache[cacheKey] = vulnerability.m_exploitCode;
            }
            
            results.push_back(vulnerability);
            return true;
        }
    }
    
    // Not in cache or score too low, perform full analysis
    float score = 0.0f;
    
    // Convert name to lowercase for analysis
    std::string name = remoteEvent->m_name;
    std::transform(name.begin(), name.end(), name.begin(), 
                  [](unsigned char c) { return std::tolower(c); });
    
    // Check location - more suspicious in certain areas
    if (remoteEvent->m_path.find("ServerScriptService") != std::string::npos) {
        score += 0.2f; // Very suspicious location
    } else if (remoteEvent->m_path.find("ReplicatedStorage") != std::string::npos) {
        score += 0.1f; // Common but not necessarily suspicious
    }
                  
    // Check for suspicious names with weighted scoring
    for (const auto& pattern : VULNERABILITY_PATTERNS) {
        if (name.find(pattern.first) != std::string::npos) {
            score += pattern.second;
        }
    }
    
    // Apply additional heuristics
    if (name.length() <= 3) {
        score += 0.2f; // Very short names are suspicious (e.g., "cmd", "run")
    }
    
    // Check if it uses a common admin command pattern
    static const std::regex adminPattern("(admin|cmd|command|exec)[_\\-]?(.*)?");
    if (std::regex_match(name, adminPattern)) {
        score += 0.3f;
    }
    
    // Try to use the model for prediction
    if (m_remoteEventModel) {
        try {
            std::string prediction = m_remoteEventModel->Predict(name);
            if (prediction == "vulnerable") {
                score += 0.25f;
            }
        } catch (...) {
            // Ignore model errors
        }
    }
    
    // Normalize score to 0-1 range
    score = std::min(std::max(score, 0.0f), 1.0f);
    
    // Cache the score for future use
    {
        std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
        g_objectVulnerabilityScores[cacheKey] = score;
    }
    
    // Only create vulnerability if score is high enough
    if (score >= 0.4f) {
        // Create vulnerability
        Vulnerability vulnerability;
        vulnerability.m_id = GenerateVulnerabilityId();
        vulnerability.m_name = "Potentially vulnerable RemoteEvent: " + remoteEvent->m_name;
        
        // Customize description based on score
        if (score >= 0.8f) {
            vulnerability.m_description = "This RemoteEvent has a highly suspicious name that strongly suggests elevated privileges.";
            vulnerability.m_tags = {"RemoteEvent", "HighRisk", "ProbableExploit"};
        } else if (score >= 0.6f) {
            vulnerability.m_description = "This RemoteEvent has a suspicious name that suggests it might have elevated privileges.";
            vulnerability.m_tags = {"RemoteEvent", "MediumRisk", "PossibleExploit"};
        } else {
            vulnerability.m_description = "This RemoteEvent has a name that could potentially indicate special privileges.";
            vulnerability.m_tags = {"RemoteEvent", "LowRisk", "SuspiciousName"};
        }
        
        vulnerability.m_type = VulnerabilityType::RemoteEvent;
        vulnerability.m_path = remoteEvent->m_path;
        vulnerability.m_severity = score;
        vulnerability.m_reliability = 0.5f + (score * 0.3f); // Higher score = higher reliability
        vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        vulnerability.m_verified = false;
        
        // Generate exploit code based on name patterns
        std::string exploitCode;
        
        if (name.find("admin") != std::string::npos) {
            exploitCode = "-- Attempt to use admin privileges via RemoteEvent\n"
                         "local event = game:GetService('ReplicatedStorage'):" + remoteEvent->m_path + "\n"
                         "if event then\n"
                         "    -- Try various admin commands\n"
                         "    event:FireServer('admin', true)\n"
                         "    event:FireServer('give', 'Weapon')\n"
                         "    event:FireServer('kick', 'OtherPlayer')\n"
                         "end";
        } else if (name.find("give") != std::string::npos) {
            exploitCode = "-- Attempt to give items via RemoteEvent\n"
                         "local event = game:GetService('ReplicatedStorage'):" + remoteEvent->m_path + "\n"
                         "if event then\n"
                         "    -- Try to get various items\n"
                         "    event:FireServer('Weapon')\n"
                         "    event:FireServer('Money', 999999)\n"
                         "    event:FireServer('AdminSword')\n"
                         "end";
        } else if (name.find("teleport") != std::string::npos) {
            exploitCode = "-- Attempt to teleport via RemoteEvent\n"
                         "local event = game:GetService('ReplicatedStorage'):" + remoteEvent->m_path + "\n"
                         "if event then\n"
                         "    -- Try teleporting to restricted locations\n"
                         "    event:FireServer(Vector3.new(0, 100, 0))\n"
                         "    event:FireServer('AdminArea')\n"
                         "    event:FireServer(game.Workspace.VIPArea.Position)\n"
                         "end";
        } else {
            // Default exploit code
            exploitCode = "-- Attempt to use the RemoteEvent with various parameters\n"
                         "local event = game:GetService('ReplicatedStorage'):" + remoteEvent->m_path + "\n"
                         "if event then\n"
                         "    -- Try different arguments\n"
                         "    event:FireServer(true)\n"
                         "    event:FireServer('admin')\n"
                         "    event:FireServer({enable=true})\n"
                         "end";
        }
        
        vulnerability.m_exploitCode = exploitCode;
        
        // Cache the exploit code
        {
            std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
            g_exploitCodeCache[cacheKey] = exploitCode;
        }
        
        results.push_back(vulnerability);
        return true;
    }
    
    return false;
}

// Analyze remote function with enhanced detection
bool VulnerabilityDetector::AnalyzeRemoteFunction(const std::shared_ptr<GameObject>& remoteFunction, std::vector<Vulnerability>& results) {
    // First check the cache
    std::string cacheKey = "RemoteFunction:" + remoteFunction->m_path;
    {
        std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
        auto scoreIt = g_objectVulnerabilityScores.find(cacheKey);
        if (scoreIt != g_objectVulnerabilityScores.end() && scoreIt->second >= 0.5f) {
            // Create vulnerability from cache
            Vulnerability vulnerability;
            vulnerability.m_id = GenerateVulnerabilityId();
            vulnerability.m_name = "Cached vulnerable RemoteFunction: " + remoteFunction->m_name;
            vulnerability.m_description = "This RemoteFunction was previously identified as potentially vulnerable.";
            vulnerability.m_type = VulnerabilityType::RemoteFunction;
            vulnerability.m_path = remoteFunction->m_path;
            vulnerability.m_severity = scoreIt->second;
            vulnerability.m_reliability = 0.6f;
            vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::system_clock::now().time_since_epoch()).count();
            vulnerability.m_verified = false;
            vulnerability.m_tags = {"RemoteFunction", "Suspicious", "Cached"};
            
            // Get cached exploit code
            auto exploitIt = g_exploitCodeCache.find(cacheKey);
            if (exploitIt != g_exploitCodeCache.end()) {
                vulnerability.m_exploitCode = exploitIt->second;
            } else {
                vulnerability.m_exploitCode = "-- Attempt to use the vulnerable RemoteFunction\n"
                                            "local func = game:GetService('ReplicatedStorage'):" + remoteFunction->m_path + "\n"
                                            "if func then\n"
                                            "    local result = func:InvokeServer('admin', true)\n"
                                            "    print('Result:', result)\n"
                                            "end";
                g_exploitCodeCache[cacheKey] = vulnerability.m_exploitCode;
            }
            
            results.push_back(vulnerability);
            return true;
        }
    }
    
    // Not in cache, perform full analysis with weighted scoring
    float score = 0.0f;
    
    // Convert name to lowercase for analysis
    std::string name = remoteFunction->m_name;
    std::transform(name.begin(), name.end(), name.begin(), 
                  [](unsigned char c) { return std::tolower(c); });
    
    // Check location - more suspicious in certain areas
    if (remoteFunction->m_path.find("ServerScriptService") != std::string::npos) {
        score += 0.2f; // Very suspicious location
    } else if (remoteFunction->m_path.find("ReplicatedStorage") != std::string::npos) {
        score += 0.1f; // Common but not necessarily suspicious
    }
                  
    // Check for suspicious names with weighted scoring
    for (const auto& pattern : VULNERABILITY_PATTERNS) {
        if (name.find(pattern.first) != std::string::npos) {
            score += pattern.second;
        }
    }
    
    // Apply additional heuristics specifically for RemoteFunctions
    if (name.find("get") != std::string::npos) {
        score += 0.3f; // "get" functions may return sensitive data
    }
    
    if (name.find("set") != std::string::npos) {
        score += 0.4f; // "set" functions may allow state modification
    }
    
    // Check special 'info' related patterns that might leak data
    if (name.find("info") != std::string::npos || 
        name.find("data") != std::string::npos || 
        name.find("stats") != std::string::npos) {
        score += 0.25f;
    }
    
    // Try to use the model for prediction
    if (m_remoteEventModel) { // Use same model as RemoteEvent for now
        try {
            std::string prediction = m_remoteEventModel->Predict(name);
            if (prediction == "vulnerable") {
                score += 0.25f;
            }
        } catch (...) {
            // Ignore model errors
        }
    }
    
    // Normalize score
    score = std::min(std::max(score, 0.0f), 1.0f);
    
    // Cache the score
    {
        std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
        g_objectVulnerabilityScores[cacheKey] = score;
    }
    
    // Only create vulnerability if score is high enough
    if (score >= 0.4f) {
        // Create vulnerability
        Vulnerability vulnerability;
        vulnerability.m_id = GenerateVulnerabilityId();
        vulnerability.m_name = "Potentially vulnerable RemoteFunction: " + remoteFunction->m_name;
        
        // Customize description based on score
        if (score >= 0.8f) {
            vulnerability.m_description = "This RemoteFunction has a highly suspicious name that strongly suggests it could be exploited.";
            vulnerability.m_tags = {"RemoteFunction", "HighRisk", "ProbableExploit"};
        } else if (score >= 0.6f) {
            vulnerability.m_description = "This RemoteFunction has a suspicious name that suggests it might be exploitable.";
            vulnerability.m_tags = {"RemoteFunction", "MediumRisk", "PossibleExploit"};
        } else {
            vulnerability.m_description = "This RemoteFunction has a name that could potentially be exploitable.";
            vulnerability.m_tags = {"RemoteFunction", "LowRisk", "SuspiciousName"};
        }
        
        vulnerability.m_type = VulnerabilityType::RemoteFunction;
        vulnerability.m_path = remoteFunction->m_path;
        vulnerability.m_severity = score;
        vulnerability.m_reliability = 0.6f + (score * 0.2f); // Higher score = higher reliability
        vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        vulnerability.m_verified = false;
        
        // Generate exploit code based on name patterns
        std::string exploitCode;
        
        if (name.find("get") != std::string::npos) {
            exploitCode = "-- Attempt to get sensitive data via RemoteFunction\n"
                         "local func = game:GetService('ReplicatedStorage'):" + remoteFunction->m_path + "\n"
                         "if func then\n"
                         "    -- Try with different parameters\n"
                         "    local result1 = func:InvokeServer()\n"
                         "    local result2 = func:InvokeServer('all')\n"
                         "    local result3 = func:InvokeServer(game.Players:GetPlayers()[1])\n"
                         "    print('Results:', result1, result2, result3)\n"
                         "end";
        } else if (name.find("set") != std::string::npos || name.find("update") != std::string::npos) {
            exploitCode = "-- Attempt to modify data via RemoteFunction\n"
                         "local func = game:GetService('ReplicatedStorage'):" + remoteFunction->m_path + "\n"
                         "if func then\n"
                         "    -- Try setting values\n"
                         "    func:InvokeServer('Money', 999999)\n"
                         "    func:InvokeServer('Level', 100)\n"
                         "    func:InvokeServer('Permission', 'Admin')\n"
                         "end";
        } else if (name.find("command") != std::string::npos || name.find("admin") != std::string::npos) {
            exploitCode = "-- Attempt to run admin commands via RemoteFunction\n"
                         "local func = game:GetService('ReplicatedStorage'):" + remoteFunction->m_path + "\n"
                         "if func then\n"
                         "    -- Try various admin commands\n"
                         "    func:InvokeServer('kick', 'PlayerName')\n"
                         "    func:InvokeServer('ban', 'PlayerName')\n"
                         "    func:InvokeServer('give', 'Weapon')\n"
                         "end";
        } else {
            // Default exploit code
            exploitCode = "-- Attempt to exploit RemoteFunction\n"
                         "local func = game:GetService('ReplicatedStorage'):" + remoteFunction->m_path + "\n"
                         "if func then\n"
                         "    -- Try with different types of arguments\n"
                         "    local result1 = func:InvokeServer()\n"
                         "    local result2 = func:InvokeServer(true)\n"
                         "    local result3 = func:InvokeServer({admin=true})\n"
                         "    print('Results:', result1, result2, result3)\n"
                         "end";
        }
        
        vulnerability.m_exploitCode = exploitCode;
        
        // Cache the exploit code
        {
            std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
            g_exploitCodeCache[cacheKey] = exploitCode;
        }
        
        results.push_back(vulnerability);
        return true;
    }
    
    return false;
}

// Analyze script with enhanced pattern detection
bool VulnerabilityDetector::AnalyzeScript(const std::shared_ptr<GameObject>& script, const std::string& code, std::vector<Vulnerability>& results) {
    bool foundVulnerabilities = false;
    
    // Skip empty scripts
    if (code.empty()) {
        return false;
    }
    
    // Check cache for this script to avoid redundant analysis
    std::string cacheKey = "Script:" + script->m_path;
    {
        std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
        auto scoreIt = g_objectVulnerabilityScores.find(cacheKey);
        if (scoreIt != g_objectVulnerabilityScores.end() && scoreIt->second > 0.6f) {
            // High score in cache, add a cached vulnerability
            Vulnerability vulnerability;
            vulnerability.m_id = GenerateVulnerabilityId();
            vulnerability.m_name = "Cached vulnerable script: " + script->m_name;
            vulnerability.m_description = "This script was previously identified as containing exploitable code.";
            vulnerability.m_type = VulnerabilityType::SecurityBypass;
            vulnerability.m_path = script->m_path;
            vulnerability.m_severity = scoreIt->second;
            vulnerability.m_reliability = 0.6f;
            vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::system_clock::now().time_since_epoch()).count();
            vulnerability.m_verified = false;
            vulnerability.m_tags = {"Script", "Cached", "SecurityBypass"};
            
            // Get cached exploit code if available
            auto exploitIt = g_exploitCodeCache.find(cacheKey);
            if (exploitIt != g_exploitCodeCache.end()) {
                vulnerability.m_exploitCode = exploitIt->second;
            } else {
                vulnerability.m_exploitCode = "-- Exploit code for script " + script->m_name + "\n"
                                            "-- This is a cached vulnerability\n"
                                            "-- Refer to the script at " + script->m_path + " for details";
            }
            
            results.push_back(vulnerability);
            return true;
        }
    }
    
    // Convert code to lowercase for analysis
    std::string lowerCode = code;
    std::transform(lowerCode.begin(), lowerCode.end(), lowerCode.begin(),
                  [](unsigned char c) { return std::tolower(c); });
    
    // Check for various script vulnerabilities
    
    // Check for filter bypasses first
    if (CheckFilterBypass(code, results)) {
        foundVulnerabilities = true;
    }
    
    // Check for backdoors
    if (CheckForBackdoors(code, results)) {
        foundVulnerabilities = true;
    }
    
    // Check for insecure remote event usage using regex for more precision
    static const std::regex remoteEventPattern(
        "([^:]+):FireServer\\((.*)\\)|"
        "([^:]+):InvokeServer\\((.*)\\)|"
        "FireServer\\((.*)\\)|"
        "InvokeServer\\((.*)\\)");
    
    std::smatch match;
    std::string::const_iterator searchStart(code.cbegin());
    
    std::vector<std::string> potentialExploits;
    
    while (std::regex_search(searchStart, code.cend(), match, remoteEventPattern)) {
        // Extract the whole match as a potential exploit
        std::string exploitSnippet = match[0];
        
        // Include some context - try to get the full line
        size_t lineStart = code.rfind('\n', match.position() + (searchStart - code.cbegin()));
        if (lineStart == std::string::npos) lineStart = 0;
        else lineStart++; // Skip the newline
        
        size_t lineEnd = code.find('\n', match.position() + (searchStart - code.cbegin()));
        if (lineEnd == std::string::npos) lineEnd = code.length();
        
        // Extract the line with the potential exploit
        std::string fullLine = code.substr(lineStart, lineEnd - lineStart);
        
        // Add to potential exploits
        potentialExploits.push_back(fullLine);
        
        // Move search position
        searchStart = match.suffix().first;
    }
    
    // If we found remote event calls, analyze them in detail
    float vulnerabilityScore = 0.0f;
    
    if (!potentialExploits.empty()) {
        // Calculate a vulnerability score based on the patterns
        
        // First, look for suspicious argument patterns
        bool hasRemoteEventCall = false;
        bool hasSuspiciousArguments = false;
        bool hasDynamicArguments = false;
        
        for (const auto& exploit : potentialExploits) {
            hasRemoteEventCall = true;
            
            // Look for dynamic arguments (variables, function calls)
            if (exploit.find('(') != std::string::npos && 
                exploit.find(')') != std::string::npos) {
                std::string args = exploit.substr(exploit.find('(') + 1);
                args = args.substr(0, args.rfind(')'));
                
                // Check for variable/dynamic arguments
                if (args.find("tostring") != std::string::npos || 
                    args.find("concat") != std::string::npos ||
                    args.find("format") != std::string::npos) {
                    hasDynamicArguments = true;
                    vulnerabilityScore += 0.3f;
                }
                
                // Check for suspicious argument keywords
                for (const auto& pattern : VULNERABILITY_PATTERNS) {
                    if (args.find(pattern.first) != std::string::npos) {
                        hasSuspiciousArguments = true;
                        vulnerabilityScore += pattern.second * 0.5f;
                    }
                }
            }
        }
        
        // If we have remote event calls with suspicious or dynamic arguments, that's a likely vulnerability
        if (hasRemoteEventCall && (hasSuspiciousArguments || hasDynamicArguments)) {
            vulnerabilityScore += 0.4f;
        }
        
        // Boost score if the script has both remote events and string manipulation
        if (hasRemoteEventCall && 
            (lowerCode.find("string.char") != std::string::npos || 
             lowerCode.find("string.byte") != std::string::npos ||
             lowerCode.find("string.format") != std::string::npos)) {
            vulnerabilityScore += 0.3f;
        }
        
        // Try to use the model for prediction
        if (m_scriptAnalysisModel) {
            try {
                // Only analyze the first part of the code if it's very long
                std::string codeForAnalysis = code.length() > 1000 ? 
                    code.substr(0, 1000) : code;
                
                std::string prediction = m_scriptAnalysisModel->Predict(codeForAnalysis);
                if (prediction == "vulnerable") {
                    vulnerabilityScore += 0.2f;
                }
            } catch (...) {
                // Ignore model errors
            }
        }
        
        // Normalize score
        vulnerabilityScore = std::min(std::max(vulnerabilityScore, 0.0f), 1.0f);
        
        // Cache the score
        {
            std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
            g_objectVulnerabilityScores[cacheKey] = vulnerabilityScore;
        }
        
        // Create vulnerabilities for each potential exploit if score is high enough
        if (vulnerabilityScore >= 0.5f) {
            for (const auto& exploit : potentialExploits) {
                Vulnerability vulnerability;
                vulnerability.m_id = GenerateVulnerabilityId();
                vulnerability.m_name = "Potential exploit in script: " + script->m_name;
                
                // Customize description based on score
                if (vulnerabilityScore >= 0.8f) {
                    vulnerability.m_description = "This script contains code that is very likely exploitable through remote events/functions.";
                    vulnerability.m_tags = {"Script", "HighRisk", "RemoteEvent", "Exploit"};
                } else if (vulnerabilityScore >= 0.6f) {
                    vulnerability.m_description = "This script contains code that might be exploitable through remote events/functions.";
                    vulnerability.m_tags = {"Script", "MediumRisk", "RemoteEvent", "Exploit"};
                } else {
                    vulnerability.m_description = "This script contains potentially suspicious remote event calls.";
                    vulnerability.m_tags = {"Script", "LowRisk", "RemoteEvent", "Suspicious"};
                }
                
                vulnerability.m_type = VulnerabilityType::SecurityBypass;
                vulnerability.m_path = script->m_path;
                vulnerability.m_exploitCode = GenerateExploitFromScript(script, exploit);
                vulnerability.m_severity = vulnerabilityScore;
                vulnerability.m_reliability = 0.5f + (vulnerabilityScore * 0.3f);
                vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::chrono::system_clock::now().time_since_epoch()).count();
                vulnerability.m_verified = false;
                
                // Add context to metadata
                vulnerability.m_metadata["context"] = exploit;
                
                // Cache the exploit code
                {
                    std::lock_guard<std::mutex> cacheLock(g_cacheMutex);
                    g_exploitCodeCache[cacheKey + ":" + std::to_string(results.size())] = vulnerability.m_exploitCode;
                }
                
                results.push_back(vulnerability);
                foundVulnerabilities = true;
            }
        }
    }
    
    return foundVulnerabilities;
}

// Helper to generate an exploit from script code
std::string VulnerabilityDetector::GenerateExploitFromScript(
    const std::shared_ptr<GameObject>& script, 
    const std::string& suspiciousCode) {
    
    // Extract remote event or function name if possible
    std::string remoteName;
    std::string remoteType;
    
    static const std::regex remotePattern("([\\w\\.]+):(?:FireServer|InvokeServer)");
    std::smatch match;
    if (std::regex_search(suspiciousCode, match, remotePattern) && match.size() > 1) {
        remoteName = match[1].str();
        remoteType = suspiciousCode.find("FireServer") != std::string::npos ? "Event" : "Function";
    } else {
        // Couldn't extract, use default remote
        remoteName = "game:GetService('ReplicatedStorage').RemoteEvent";
        remoteType = "Event";
    }
    
    std::string exploitCode;
    
    if (remoteType == "Event") {
        exploitCode = "-- Exploit based on script " + script->m_name + "\n"
                     "-- Suspicious code: " + suspiciousCode + "\n\n"
                     "-- Attempt to find and use the RemoteEvent\n"
                     "local remote = " + remoteName + "\n"
                     "if remote then\n"
                     "    -- Try different arguments based on the script\n"
                     "    remote:FireServer()\n";
        
        // Add more specific exploit attempts based on the suspicious code
        if (suspiciousCode.find("admin") != std::string::npos) {
            exploitCode += "    remote:FireServer('admin', true)\n";
        }
        if (suspiciousCode.find("give") != std::string::npos) {
            exploitCode += "    remote:FireServer('give', 'Weapon')\n";
        }
        if (suspiciousCode.find("kick") != std::string::npos || suspiciousCode.find("ban") != std::string::npos) {
            exploitCode += "    remote:FireServer('kick', game.Players:GetPlayers()[1].Name)\n";
        }
        
        exploitCode += "end";
    } else {
        exploitCode = "-- Exploit based on script " + script->m_name + "\n"
                     "-- Suspicious code: " + suspiciousCode + "\n\n"
                     "-- Attempt to find and use the RemoteFunction\n"
                     "local remote = " + remoteName + "\n"
                     "if remote then\n"
                     "    -- Try different arguments based on the script\n"
                     "    local result = remote:InvokeServer()\n"
                     "    print('Result:', result)\n";
        
        // Add more specific exploit attempts
        if (suspiciousCode.find("admin") != std::string::npos) {
            exploitCode += "    local adminResult = remote:InvokeServer('admin', true)\n"
                           "    print('Admin Result:', adminResult)\n";
        }
        
        exploitCode += "end";
    }
    
    return exploitCode;
}

// Check for filter bypasses with enhanced detection
bool VulnerabilityDetector::CheckFilterBypass(const std::string& code, std::vector<Vulnerability>& results) {
    // Calculate a bypass score based on patterns
    float bypassScore = 0.0f;
    
    // Check for string manipulation techniques commonly used to bypass filters
    static const std::vector<std::pair<std::string, float>> filterBypassPatterns = {
        {"string.char", 0.6f},
        {"string.byte", 0.6f},
        {"string.sub", 0.5f},
        {"string.gsub", 0.6f},
        {"string.format", 0.4f},
        {"string.rep", 0.3f},
        {"table.concat", 0.5f},
        {"utf8.char", 0.7f},
        {".char(", 0.5f},
        {".byte(", 0.5f},
        {"\\x", 0.7f},     // Hex escapes
        {"\\u", 0.7f},     // Unicode escapes
        {"tostring", 0.3f}
    };
    
    // Check for remote event/function usage
    bool hasRemoteEventUsage = 
        code.find("FireServer") != std::string::npos ||
        code.find("InvokeServer") != std::string::npos;
    
    if (!hasRemoteEventUsage) {
        return false; // No remote events, no bypass vulnerability
    }
    
    // Check for string manipulation patterns
    bool hasStringManipulation = false;
    std::vector<std::string> detectedPatterns;
    
    for (const auto& pattern : filterBypassPatterns) {
        if (code.find(pattern.first) != std::string::npos) {
            bypassScore += pattern.second;
            hasStringManipulation = true;
            detectedPatterns.push_back(pattern.first);
        }
    }
    
    // Check for encoding/decoding patterns
    static const std::regex encodingPattern(
        "for\\s+[^,]+,[^,]+\\s+in\\s+([^:]+):([^\\(]*)\\(([^\\)]*)\\)",
        std::regex::icase);
    
    std::smatch encMatch;
    if (std::regex_search(code, encMatch, encodingPattern)) {
        bypassScore += 0.4f;
        hasStringManipulation = true;
        detectedPatterns.push_back("encoding loop");
    }
    
    // Look for suspicious patterns near remote event calls
    static const std::regex remoteEventRegex(
        "([\\w\\.]+):(?:FireServer|InvokeServer)\\((.*)\\)",
        std::regex::icase);
    
    std::string::const_iterator searchStart(code.cbegin());
    std::string suspiciousCall;
    
    while (std::regex_search(searchStart, code.cend(), encMatch, remoteEventRegex)) {
        std::string args = encMatch[2].str();
        
        // Check if args contain any string manipulation or encoded data
        for (const auto& pattern : filterBypassPatterns) {
            if (args.find(pattern.first) != std::string::npos) {
                bypassScore += pattern.second * 1.5f; // Higher score if directly in arguments
                suspiciousCall = encMatch[0].str();
                break;
            }
        }
        
        searchStart = encMatch.suffix().first;
    }
    
    // Only create vulnerability if we have string manipulation and remote events
    if (hasStringManipulation && hasRemoteEventUsage && bypassScore >= 0.5f) {
        // Normalize score to 0-1 range
        bypassScore = std::min(std::max(bypassScore, 0.5f), 1.0f);
        
        // Create vulnerability
        Vulnerability vulnerability;
        vulnerability.m_id = GenerateVulnerabilityId();
        
        // Set name and description based on score
        if (bypassScore >= 0.8f) {
            vulnerability.m_name = "High-confidence filter bypass detected";
            vulnerability.m_description = "This code uses advanced string manipulation techniques commonly used to bypass text filters in remote events.";
            vulnerability.m_tags = {"FilterBypass", "StringManipulation", "HighRisk"};
            vulnerability.m_reliability = 0.8f;
        } else if (bypassScore >= 0.6f) {
            vulnerability.m_name = "Potential filter bypass";
            vulnerability.m_description = "This code combines string manipulation with remote events, which might be used to bypass text filters.";
            vulnerability.m_tags = {"FilterBypass", "StringManipulation", "MediumRisk"};
            vulnerability.m_reliability = 0.7f;
        } else {
            vulnerability.m_name = "Possible filter bypass techniques";
            vulnerability.m_description = "This code contains some string manipulation techniques that could potentially be used for filter bypassing.";
            vulnerability.m_tags = {"FilterBypass", "StringManipulation", "LowRisk"};
            vulnerability.m_reliability = 0.6f;
        }
        
        vulnerability.m_type = VulnerabilityType::FilterBypass;
        vulnerability.m_severity = bypassScore;
        vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        vulnerability.m_verified = false;
        
        // Record patterns found in metadata
        std::string patternsStr;
        for (const auto& pattern : detectedPatterns) {
            if (!patternsStr.empty()) patternsStr += ", ";
            patternsStr += pattern;
        }
        vulnerability.m_metadata["detected_patterns"] = patternsStr;
        
        // Generate exploit code - create a script that mimics the bypass
        std::string exploitCode = "-- Filter bypass exploit\n\n";
        
        // Extract the bypass code if possible
        std::regex filterBypassRegex("([\\s\\S]{0,100}(?:string\\.[a-z]+|utf8\\.[a-z]+|table\\.concat|tostring)[\\s\\S]{0,150}(?:FireServer|InvokeServer)[\\s\\S]{0,50})");
        std::smatch bypassMatch;
        if (std::regex_search(code, bypassMatch, filterBypassRegex) && bypassMatch.size() > 0) {
            std::string contextCode = bypassMatch[0].str();
            // Clean up the code
            contextCode = std::regex_replace(contextCode, std::regex("^\\s+|\\s+$"), "");
            
            exploitCode += "-- Original bypass code:\n";
            exploitCode += contextCode + "\n\n";
            
            // Now create a modified version for exploitation
            exploitCode += "-- Modified version for exploitation:\n";
            exploitCode += "local remote = game:GetService('ReplicatedStorage'):FindFirstChild('RemoteEvent') -- Find the correct remote\n\n";
            exploitCode += "-- String manipulation to bypass filter\n";
            
            if (contextCode.find("string.char") != std::string::npos) {
                exploitCode += "local bypassString = string.char(97,100,109,105,110) -- 'admin'\n";
            } else if (contextCode.find("string.byte") != std::string::npos) {
                exploitCode += "local chars = {}\n";
                exploitCode += "for i = 1, #\"admin\" do\n";
                exploitCode += "    chars[i] = string.byte(\"admin\", i)\n";
                exploitCode += "end\n";
                exploitCode += "local bypassString = string.char(unpack(chars))\n";
            } else {
                exploitCode += "local bypassString = '\\x61\\x64\\x6d\\x69\\x6e' -- Hex encoded 'admin'\n";
            }
            
            exploitCode += "\n-- Attempt to use the bypass\n";
            exploitCode += "if remote then\n";
            exploitCode += "    remote:FireServer(bypassString, true) -- Try with bypassed 'admin' string\n";
            exploitCode += "end";
            
        } else if (!suspiciousCall.empty()) {
            // Use the suspicious call if we found one
            exploitCode += "-- Based on suspicious remote call:\n";
            exploitCode += suspiciousCall + "\n\n";
            exploitCode += "-- Modified version for exploitation:\n";
            exploitCode += "local remote = " + suspiciousCall.substr(0, suspiciousCall.find(':')) + "\n";
            exploitCode += "if remote then\n";
            exploitCode += "    -- Try with encoded admin arguments\n";
            exploitCode += "    local bypassedAdmin = string.char(97,100,109,105,110)\n";
            exploitCode += "    remote:FireServer(bypassedAdmin, true)\n";
            exploitCode += "end";
        } else {
            // Generic exploit if we couldn't extract specific code
            exploitCode += "-- Generic filter bypass example:\n\n";
            exploitCode += "local remote = game:GetService('ReplicatedStorage'):FindFirstChild('RemoteEvent')\n";
            exploitCode += "if remote then\n";
            exploitCode += "    -- Method 1: Character code bypass\n";
            exploitCode += "    local bypass1 = string.char(97,100,109,105,110) -- 'admin'\n";
            exploitCode += "    remote:FireServer(bypass1)\n\n";
            exploitCode += "    -- Method 2: Unicode escape bypass\n";
            exploitCode += "    local bypass2 = '\\u{0061}\\u{0064}\\u{006d}\\u{0069}\\u{006e}' -- 'admin'\n";
            exploitCode += "    remote:FireServer(bypass2)\n";
            exploitCode += "end";
        }
        
        vulnerability.m_exploitCode = exploitCode;
        
        results.push_back(vulnerability);
        return true;
    }
    
    return false;
}

// Check for backdoors with enhanced detection
bool VulnerabilityDetector::CheckForBackdoors(const std::string& code, std::vector<Vulnerability>& results) {
    // Calculate a backdoor score based on patterns
    float backdoorScore = 0.0f;
    
    // Check for dynamic code execution
    static const std::vector<std::pair<std::string, float>> dynamicExecutionPatterns = {
        {"loadstring", 0.8f},
        {"load", 0.7f},
        {"HttpGet", 0.7f},
        {"GetAsync", 0.6f},
        {"DownloadString", 0.6f},
        {"getfenv", 0.5f},
        {"setfenv", 0.6f},
        {"rawget", 0.4f},
        {"rawset", 0.4f},
        {"getrawmetatable", 0.5f},
        {"setrawmetatable", 0.6f},
        {"hookfunction", 0.7f},
        {"newcclosure", 0.6f},
        {"eval", 0.7f},
        {"dofile", 0.7f},
        {"require", 0.3f},   // Lower score because it's commonly used legitimately
        {"pcall", 0.2f},     // Lower score because it's commonly used legitimately
        {"xpcall", 0.2f}     // Lower score because it's commonly used legitimately
    };
    
    // Check for service access patterns
    static const std::vector<std::pair<std::string, float>> serviceAccessPatterns = {
        {"GetService", 0.3f},
        {"ServerScriptService", 0.5f},
        {"ServerStorage", 0.5f},
        {"JointsService", 0.4f},
        {"RunService", 0.3f},
        {"HttpService", 0.5f},
        {"game:service", 0.4f}
    };
    
    // Check for suspicious URLs or domain pattern
    static const std::regex urlPattern("https?://([^/\\s]+)", std::regex::icase);
    std::smatch urlMatch;
    bool hasUrl = std::regex_search(code, urlMatch, urlPattern);
    
    if (hasUrl && urlMatch.size() > 1) {
        // Score based on domain reputation
        std::string domain = urlMatch[1].str();
        std::transform(domain.begin(), domain.end(), domain.begin(), 
                       [](unsigned char c){ return std::tolower(c); });
        
        // Check for known suspicious domains
        if (domain.find("pastebin.com") != std::string::npos || 
            domain.find("gist.github") != std::string::npos || 
            domain.find("raw.githubusercontent") != std::string::npos) {
            backdoorScore += 0.6f;
        } else if (domain.find("discord") != std::string::npos || 
                   domain.find("webhook") != std::string::npos) {
            // Discord webhooks often used for data exfiltration
            backdoorScore += 0.7f;
        } else {
            // Generic URL
            backdoorScore += 0.4f;
        }
    }
    
    // Check for dynamic execution patterns
    bool hasDynamicExecution = false;
    std::vector<std::string> detectedPatterns;
    
    for (const auto& pattern : dynamicExecutionPatterns) {
        if (code.find(pattern.first) != std::string::npos) {
            backdoorScore += pattern.second;
            hasDynamicExecution = true;
            detectedPatterns.push_back(pattern.first);
        }
    }
    
    // Check for service access patterns
    bool hasServiceAccess = false;
    
    for (const auto& pattern : serviceAccessPatterns) {
        if (code.find(pattern.first) != std::string::npos) {
            backdoorScore += pattern.second;
            hasServiceAccess = true;
            detectedPatterns.push_back(pattern.first);
        }
    }
    
    // Check for obfuscated code patterns
    static const std::regex obfuscationPattern(
        "\\b([a-zA-Z0-9_]+)\\s*=\\s*('|\")([^\\2]+)\\2\\s*;?\\s*([a-zA-Z0-9_]+)\\s*=\\s*\\1\\s*:\\s*([gs][es]\\w+)\\s*",
        std::regex::icase);
    
    if (std::regex_search(code, obfuscationPattern)) {
        backdoorScore += 0.5f;
        detectedPatterns.push_back("obfuscation");
    }
    
    // Check for payload patterns similar to known backdoors
    static const std::vector<std::pair<std::string, float>> payloadPatterns = {
        {"grab", 0.4f},
        {"backdoor", 0.8f},
        {"remote.Parent", 0.5f},
        {"Disabled = false", 0.4f},
        {"delete", 0.3f},
        {"destroy", 0.3f},
        {"kill", 0.4f},
        {"payload", 0.6f},
        {"inject", 0.7f},
        {"exploit", 0.7f}
    };
    
    // Check for payload patterns
    for (const auto& pattern : payloadPatterns) {
        if (code.find(pattern.first) != std::string::npos) {
            backdoorScore += pattern.second;
            detectedPatterns.push_back(pattern.first);
        }
    }
    
    // Only create vulnerability if score is high enough
    if ((hasDynamicExecution || hasUrl) && (hasServiceAccess || backdoorScore >= 0.6f)) {
        // Normalize score to 0-1 range, but keep high scores high
        backdoorScore = std::min(std::max(backdoorScore, 0.6f), 1.0f);
        
        // Create vulnerability
        Vulnerability vulnerability;
        vulnerability.m_id = GenerateVulnerabilityId();
        
        // Set name and description based on score
        if (backdoorScore >= 0.8f) {
            vulnerability.m_name = "High-confidence backdoor detected";
            vulnerability.m_description = "This code contains strong indicators of a backdoor, including dynamic code execution and suspicious service access.";
            vulnerability.m_tags = {"Backdoor", "DynamicExecution", "HighRisk", "MaliciousCode"};
            vulnerability.m_reliability = 0.9f;
        } else if (backdoorScore >= 0.7f) {
            vulnerability.m_name = "Potential backdoor script";
            vulnerability.m_description = "This code shows patterns consistent with backdoor scripts, such as remote code loading and service manipulation.";
            vulnerability.m_tags = {"Backdoor", "DynamicExecution", "MediumRisk"};
            vulnerability.m_reliability = 0.8f;
        } else {
            vulnerability.m_name = "Suspicious code patterns detected";
            vulnerability.m_description = "This code contains some patterns that are sometimes used in backdoor scripts.";
            vulnerability.m_tags = {"Suspicious", "DynamicExecution", "LowRisk"};
            vulnerability.m_reliability = 0.7f;
        }
        
        vulnerability.m_type = VulnerabilityType::BackdoorScript;
        vulnerability.m_severity = backdoorScore;
        vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        vulnerability.m_verified = false;
        
        // Record patterns found in metadata
        std::string patternsStr;
        for (const auto& pattern : detectedPatterns) {
            if (!patternsStr.empty()) patternsStr += ", ";
            patternsStr += pattern;
        }
        vulnerability.m_metadata["detected_patterns"] = patternsStr;
        
        // Save URL if found
        if (hasUrl) {
            vulnerability.m_metadata["url"] = urlMatch[0].str();
        }
        
        // Extract the backdoor code
        std::regex backdoorRegex;
        
        if (hasUrl) {
            // Extract code around URL
            backdoorRegex = std::regex("([\\s\\S]{0,100}" + std::regex_escape(urlMatch[0].str()) + "[\\s\\S]{0,100})");
        } else if (hasDynamicExecution && !detectedPatterns.empty()) {
            // Extract code around dynamic execution
            backdoorRegex = std::regex("([\\s\\S]{0,100}" + std::regex_escape(detectedPatterns[0]) + "[\\s\\S]{0,150})");
        } else {
            // Default regex for general suspicious code
            backdoorRegex = std::regex("([\\s\\S]{0,300}(?:GetService|loadstring|HttpGet)[\\s\\S]{0,300})");
        }
        
        // Generate exploit code based on the backdoor
        std::string exploitCode = "-- Backdoor detection script\n\n";
        
        std::smatch backdoorMatch;
        if (std::regex_search(code, backdoorMatch, backdoorRegex) && backdoorMatch.size() > 0) {
            std::string contextCode = backdoorMatch[0].str();
            // Clean up the code
            contextCode = std::regex_replace(contextCode, std::regex("^\\s+|\\s+$"), "");
            
            exploitCode += "-- Detected backdoor code:\n";
            exploitCode += contextCode + "\n\n";
            
            // Create an analyzer to understand the backdoor
            exploitCode += "-- Analysis and potential exploitation:\n\n";
            
            // Check for common backdoor types
            if (contextCode.find("loadstring") != std::string::npos && hasUrl) {
                exploitCode += "-- This appears to be a remote code execution backdoor\n";
                exploitCode += "-- The script loads and executes code from an external URL\n\n";
                
                exploitCode += "-- To detect this backdoor in your game, look for:\n";
                exploitCode += "local backdoors = {}\n\n";
                exploitCode += "-- Scan for HTTP requests or loadstring usage\n";
                exploitCode += "for _, instance in pairs(game:GetDescendants()) do\n";
                exploitCode += "    if instance:IsA('Script') or instance:IsA('LocalScript') then\n";
                exploitCode += "        local source = instance.Source\n";
                exploitCode += "        if source:find('HttpGet') and source:find('loadstring') then\n";
                exploitCode += "            table.insert(backdoors, instance)\n";
                exploitCode += "            print('Potential backdoor found: ' .. instance:GetFullName())\n";
                exploitCode += "        end\n";
                exploitCode += "    end\n";
                exploitCode += "end\n";
            } else if (contextCode.find("GetService") != std::string::npos && 
                      (contextCode.find("ServerStorage") != std::string::npos || 
                       contextCode.find("ServerScriptService") != std::string::npos)) {
                exploitCode += "-- This appears to be a server storage access backdoor\n";
                exploitCode += "-- The script tries to access or modify server-side resources\n\n";
                
                exploitCode += "-- To investigate server access:\n";
                exploitCode += "local success, serverStorage = pcall(function()\n";
                exploitCode += "    return game:GetService('ServerStorage')\n";
                exploitCode += "end)\n\n";
                exploitCode += "if success then\n";
                exploitCode += "    print('Successfully accessed ServerStorage - potential security issue')\n";
                exploitCode += "    -- Enumerate contents\n";
                exploitCode += "    for _, item in pairs(serverStorage:GetChildren()) do\n";
                exploitCode += "        print('Found: ' .. item.Name .. ' (' .. item.ClassName .. ')')\n";
                exploitCode += "    end\n";
                exploitCode += "end\n";
            } else {
                exploitCode += "-- Generic backdoor analysis\n";
                exploitCode += "-- This code contains suspicious patterns that might allow unauthorized access\n\n";
                
                exploitCode += "-- To check for this backdoor type:\n";
                exploitCode += "local suspiciousObjects = {}\n\n";
                exploitCode += "-- Look for objects with suspicious names or properties\n";
                exploitCode += "for _, instance in pairs(game:GetDescendants()) do\n";
                exploitCode += "    local name = instance.Name:lower()\n";
                exploitCode += "    if name:find('remote') or name:find('function') or name:find('event') then\n";
                exploitCode += "        if instance:IsA('RemoteEvent') or instance:IsA('RemoteFunction') then\n";
                exploitCode += "            table.insert(suspiciousObjects, instance)\n";
                exploitCode += "            print('Suspicious remote: ' .. instance:GetFullName())\n";
                exploitCode += "            \n";
                exploitCode += "            -- Try to invoke with various tests\n";
                exploitCode += "            pcall(function()\n";
                exploitCode += "                if instance:IsA('RemoteEvent') then\n";
                exploitCode += "                    instance:FireServer('test')\n";
                exploitCode += "                else\n";
                exploitCode += "                    instance:InvokeServer('test')\n";
                exploitCode += "                end\n";
                exploitCode += "            end)\n";
                exploitCode += "        end\n";
                exploitCode += "    end\n";
                exploitCode += "end\n";
            }
        } else {
            // Generic exploit if we couldn't extract specific code
            exploitCode += "-- Generic backdoor detection:\n\n";
            exploitCode += "-- Possible backdoor techniques detected:\n";
            
            for (const auto& pattern : detectedPatterns) {
                exploitCode += "-- - " + pattern + "\n";
            }
            
            exploitCode += "\n-- To check for backdoors in your game:\n";
            exploitCode += "local suspiciousScripts = {}\n\n";
            exploitCode += "-- Scan all scripts in the game\n";
            exploitCode += "for _, instance in pairs(game:GetDescendants()) do\n";
            exploitCode += "    if instance:IsA('Script') or instance:IsA('LocalScript') or instance:IsA('ModuleScript') then\n";
            exploitCode += "        local source = instance.Source\n";
            exploitCode += "        \n";
            exploitCode += "        -- Check for suspicious patterns\n";
            exploitCode += "        local isSuspicious = false\n";
            exploitCode += "        if source:find('loadstring') or source:find('HttpGet') then\n";
            exploitCode += "            isSuspicious = true\n";
            exploitCode += "        end\n";
            exploitCode += "        \n";
            exploitCode += "        if isSuspicious then\n";
            exploitCode += "            table.insert(suspiciousScripts, instance)\n";
            exploitCode += "            print('Potential backdoor: ' .. instance:GetFullName())\n";
            exploitCode += "        end\n";
            exploitCode += "    end\n";
            exploitCode += "end\n";
        }
        
        vulnerability.m_exploitCode = exploitCode;
        
        results.push_back(vulnerability);
        return true;
    }
    
    return false;
}

// Check for network ownership vulnerabilities with enhanced detection
bool VulnerabilityDetector::CheckNetworkOwnership(
    const std::shared_ptr<GameObject>& part, 
    std::vector<Vulnerability>& results) {
    
    // Calculate a network ownership score based on part properties
    float score = 0.0f;
    
    // Check for common network ownership vulnerability indicators
    bool hasPhysicsEnabled = false;
    bool hasLowMass = false;
    bool hasCustomNetworkOwnership = false;
    bool isAnchored = true;  // Default to true, will be set to false if we find it's not
    
    // Check part properties
    for (const auto& prop : part->m_properties) {
        // Convert property name to lowercase for case-insensitive comparison
        std::string propName = prop.first;
        std::transform(propName.begin(), propName.end(), propName.begin(),
                      [](unsigned char c) { return std::tolower(c); });
        
        if (propName == "anchored") {
            isAnchored = (prop.second == "true" || prop.second == "1");
            if (!isAnchored) {
                score += 0.3f; // Unanchored parts may be vulnerable
            }
        } else if (propName == "canbecollided" && (prop.second == "true" || prop.second == "1")) {
            score += 0.2f; // Collidable objects are more likely to be vulnerable
        } else if (propName == "massless" && (prop.second == "true" || prop.second == "1")) {
            score += 0.3f; // Massless objects are more likely to be vulnerable
            hasLowMass = true;
        } else if (propName == "mass") {
            try {
                float mass = std::stof(prop.second);
                if (mass < 1.0f) {
                    score += 0.2f; // Low mass objects are more likely to be vulnerable
                    hasLowMass = true;
                }
            } catch (...) {
                // Ignore conversion errors
            }
        } else if (propName == "networkowner" || propName == "networkownership") {
            score += 0.4f; // Explicit network ownership settings are suspicious
            hasCustomNetworkOwnership = true;
        } else if (propName == "physicsenabled" && (prop.second == "true" || prop.second == "1")) {
            score += 0.3f; // Physics enabled parts are more vulnerable
            hasPhysicsEnabled = true;
        }
    }
    
    // Check class-specific vulnerabilities
    if (part->m_className == "VehicleSeat" || 
        part->m_className == "Seat" || 
        part->m_className == "SpawnLocation") {
        score += 0.4f; // These parts often have network ownership vulnerabilities
    }
    
    // Check path for suspicious locations
    if (part->m_path.find("Workspace") != std::string::npos) {
        score += 0.1f; // Parts in workspace are more accessible
        
        // Look for specific workspace sublocations
        if (part->m_path.find("Map") != std::string::npos ||
            part->m_path.find("Game") != std::string::npos) {
            score += 0.1f; // Common game area parts
        }
    }
    
    // Unanchored physics-enabled parts have highest risk
    if (!isAnchored && hasPhysicsEnabled) {
        score += 0.3f;
    }
    
    // Parts with custom network ownership settings and physics
    if (hasCustomNetworkOwnership && hasPhysicsEnabled) {
        score += 0.2f;
    }
    
    // Normalize score
    score = std::min(std::max(score, 0.0f), 1.0f);
    
    // Only create vulnerability if score is high enough
    if (score >= 0.5f) {
        // Create vulnerability
        Vulnerability vulnerability;
        vulnerability.m_id = GenerateVulnerabilityId();
        
        // Set name and description based on score and properties
        if (score >= 0.8f) {
            vulnerability.m_name = "Critical network ownership vulnerability in " + part->m_name;
            vulnerability.m_description = "This part has high risk of network ownership exploitation due to its physics properties and configuration.";
            vulnerability.m_tags = {"NetworkOwnership", "PhysicsExploit", "HighRisk"};
            vulnerability.m_reliability = 0.8f;
        } else if (score >= 0.6f) {
            vulnerability.m_name = "Potential network ownership vulnerability in " + part->m_name;
            vulnerability.m_description = "This part shows properties that could allow network ownership manipulation.";
            vulnerability.m_tags = {"NetworkOwnership", "PhysicsExploit", "MediumRisk"};
            vulnerability.m_reliability = 0.6f;
        } else {
            vulnerability.m_name = "Possible network ownership issues with " + part->m_name;
            vulnerability.m_description = "This part has some properties that could potentially lead to network ownership issues.";
            vulnerability.m_tags = {"NetworkOwnership", "LowRisk"};
            vulnerability.m_reliability = 0.5f;
        }
        
        vulnerability.m_type = VulnerabilityType::NetworkOwnership;
        vulnerability.m_path = part->m_path;
        vulnerability.m_severity = score;
        vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        vulnerability.m_verified = false;
        
        // Add metadata about the part
        vulnerability.m_metadata["className"] = part->m_className;
        vulnerability.m_metadata["anchored"] = isAnchored ? "true" : "false";
        vulnerability.m_metadata["physicsEnabled"] = hasPhysicsEnabled ? "true" : "false";
        vulnerability.m_metadata["lowMass"] = hasLowMass ? "true" : "false";
        
        // Generate exploit code based on part type
        std::string exploitCode = "-- Network ownership exploit for " + part->m_name + "\n\n";
        
        if (part->m_className == "VehicleSeat" || part->m_className == "Seat") {
            exploitCode += "-- This exploit targets a seat/vehicle with potential network ownership issues\n\n";
            
            exploitCode += "local seat = game:GetService('Workspace'):" + part->m_path + "\n";
            exploitCode += "local player = game:GetService('Players').LocalPlayer\n";
            exploitCode += "local character = player.Character or player.CharacterAdded:Wait()\n\n";
            
            exploitCode += "-- Function to exploit network ownership\n";
            exploitCode += "local function exploitNetworkOwnership()\n";
            exploitCode += "    -- Step 1: Sit in the seat to gain network ownership\n";
            exploitCode += "    seat:Sit(character:FindFirstChildOfClass('Humanoid'))\n";
            exploitCode += "    wait(0.5) -- Wait for network ownership transfer\n\n";
            
            exploitCode += "    -- Step 2: Use network ownership to move or manipulate objects\n";
            exploitCode += "    local targetParts = workspace:FindFirstChild('Map'):GetDescendants()\n";
            exploitCode += "    for _, part in pairs(targetParts) do\n";
            exploitCode += "        if part:IsA('BasePart') and not part.Anchored then\n";
            exploitCode += "            -- Try to apply force or teleport parts\n";
            exploitCode += "            pcall(function()\n";
            exploitCode += "                part.CFrame = CFrame.new(0, 1000, 0) -- Teleport high up\n";
            exploitCode += "                part:ApplyImpulse(Vector3.new(0, 10000, 0)) -- Launch upward\n";
            exploitCode += "            end)\n";
            exploitCode += "        end\n";
            exploitCode += "    end\n";
            exploitCode += "end\n\n";
            
            exploitCode += "-- Execute the exploit\n";
            exploitCode += "exploitNetworkOwnership()\n";
        } else if (!isAnchored && hasPhysicsEnabled) {
            exploitCode += "-- This exploit targets an unanchored physics part\n\n";
            
            exploitCode += "local part = game:GetService('Workspace'):" + part->m_path + "\n";
            exploitCode += "local player = game:GetService('Players').LocalPlayer\n";
            exploitCode += "local character = player.Character or player.CharacterAdded:Wait()\n\n";
            
            exploitCode += "-- Function to exploit network ownership\n";
            exploitCode += "local function exploitNetworkOwnership()\n";
            exploitCode += "    -- Step 1: Try to gain network ownership by getting close\n";
            exploitCode += "    local humanoidRootPart = character:WaitForChild('HumanoidRootPart')\n";
            exploitCode += "    local originalPosition = humanoidRootPart.CFrame\n\n";
            
            exploitCode += "    -- Move to the part\n";
            exploitCode += "    humanoidRootPart.CFrame = part.CFrame * CFrame.new(0, 3, 0)\n";
            exploitCode += "    wait(1) -- Wait to gain ownership\n\n";
            
            exploitCode += "    -- Step 2: Try to manipulate the part\n";
            exploitCode += "    for i = 1, 10 do\n";
            exploitCode += "        pcall(function()\n";
            exploitCode += "            -- Apply forces or teleport\n";
            exploitCode += "            part.Velocity = Vector3.new(0, 100, 0)\n";
            exploitCode += "            part:ApplyImpulse(Vector3.new(0, 1000, 0))\n";
            exploitCode += "        end)\n";
            exploitCode += "        wait(0.1)\n";
            exploitCode += "    end\n\n";
            
            exploitCode += "    -- Return to original position\n";
            exploitCode += "    humanoidRootPart.CFrame = originalPosition\n";
            exploitCode += "end\n\n";
            
            exploitCode += "-- Execute the exploit\n";
            exploitCode += "exploitNetworkOwnership()\n";
        } else {
            exploitCode += "-- Generic network ownership exploit attempt\n\n";
            
            exploitCode += "local part = game:GetService('Workspace'):" + part->m_path + "\n";
            exploitCode += "local player = game:GetService('Players').LocalPlayer\n\n";
            
            exploitCode += "-- Function to check and exploit network ownership\n";
            exploitCode += "local function checkNetworkOwnership()\n";
            exploitCode += "    -- Check if we can modify the part\n";
            exploitCode += "    local success = pcall(function()\n";
            exploitCode += "        -- Try to set network ownership if possible\n";
            exploitCode += "        if part:IsA('BasePart') and part:CanSetNetworkOwnership() then\n";
            exploitCode += "            part:SetNetworkOwner(player)\n";
            exploitCode += "            return true\n";
            exploitCode += "        end\n";
            
            exploitCode += "        -- Try direct property manipulation\n";
            exploitCode += "        local originalCFrame = part.CFrame\n";
            exploitCode += "        part.CFrame = CFrame.new(0, 100, 0)\n";
            exploitCode += "        wait(0.1)\n";
            exploitCode += "        part.CFrame = originalCFrame -- Restore position\n";
            exploitCode += "    end)\n\n";
            
            exploitCode += "    if success then\n";
            exploitCode += "        print('Successfully exploited network ownership on ' .. part:GetFullName())\n";
            exploitCode += "    else\n";
            exploitCode += "        print('Failed to exploit network ownership')\n";
            exploitCode += "    end\n";
            exploitCode += "end\n\n";
            
            exploitCode += "-- Execute the exploit\n";
            exploitCode += "checkNetworkOwnership()\n";
        }
        
        vulnerability.m_exploitCode = exploitCode;
        
        results.push_back(vulnerability);
        return true;
    }
    
    return false;
}
        std::regex backdoorRegex("(loadstring|HttpGet|getfenv).*\\(.*\\)");
        std::smatch match;
        if (std::regex_search(code, match, backdoorRegex)) {
            vulnerability.m_exploitCode = match[0];
        } else {
            vulnerability.m_exploitCode = "-- Backdoor code not extracted";
        }
        
        // Add vulnerability
        AddVulnerability(result, vulnerability);
        
        return true;
    }
    
    return false;
}

// Check network ownership
bool VulnerabilityDetector::CheckNetworkOwnership(const std::shared_ptr<GameObject>& part, ScanResult& result) {
    // Check for network ownership vulnerabilities
    auto it = part->m_properties.find("Anchored");
    if (it != part->m_properties.end() && it->second == "false") {
        // Unanchored parts might be exploitable
        
        // Check for other properties that might indicate a vulnerability
        bool isExploitable = false;
        
        // Check if it has a high mass
        auto massIt = part->m_properties.find("Mass");
        if (massIt != part->m_properties.end()) {
            try {
                float mass = std::stof(massIt->second);
                if (mass > 100.0f) {
                    isExploitable = true;
                }
            } catch (...) {
                // Ignore conversion errors
            }
        }
        
        // Check if it's a vehicle seat
        auto classNameIt = part->m_properties.find("ClassName");
        if (classNameIt != part->m_properties.end() && classNameIt->second == "VehicleSeat") {
            isExploitable = true;
        }
        
        if (isExploitable) {
            // Create vulnerability
            Vulnerability vulnerability;
            vulnerability.m_id = GenerateVulnerabilityId();
            vulnerability.m_name = "Network ownership vulnerability";
            vulnerability.m_description = "This part is unanchored and might be exploitable through network ownership manipulation.";
            vulnerability.m_type = VulnerabilityType::NetworkOwnership;
            vulnerability.m_path = part->m_path;
            vulnerability.m_severity = 0.6f;
            vulnerability.m_reliability = 0.5f;
            vulnerability.m_discoveryTime = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::system_clock::now().time_since_epoch()).count();
            vulnerability.m_verified = false;
            vulnerability.m_tags = {"NetworkOwnership", "Physics", "Exploit"};
            
            // Generate exploit code
            vulnerability.m_exploitCode = "-- Network ownership exploit\n"
                                         "local part = workspace:FindFirstChild(\"" + part->m_name + "\")\n"
                                         "if part then\n"
                                         "    -- Take control of the part\n"
                                         "    part:SetNetworkOwner(game.Players.LocalPlayer)\n"
                                         "    \n"
                                         "    -- Manipulate the part\n"
                                         "    part.Velocity = Vector3.new(0, 1000, 0) -- Launch up\n"
                                         "end";
            
            // Add vulnerability
            AddVulnerability(result, vulnerability);
            
            return true;
        }
    }
    
    return false;
}

// Extract potential exploits
std::vector<std::string> VulnerabilityDetector::ExtractPotentialExploits(const std::string& code) {
    std::vector<std::string> exploits;
    
    // Look for remote event/function calls
    std::regex remoteCallRegex("([\\w.]+):FireServer\\(([^)]*)\\)|([\\w.]+):InvokeServer\\(([^)]*)\\)");
    std::string::const_iterator searchStart(code.cbegin());
    std::smatch match;
    
    while (std::regex_search(searchStart, code.cend(), match, remoteCallRegex)) {
        // Extract remote and arguments
        std::string remote = match[1].length() > 0 ? match[1] : match[3];
        std::string args = match[2].length() > 0 ? match[2] : match[4];
        
        // Create exploit code
        std::string exploit = "-- Potential exploit\n"
                             "local remote = " + remote + "\n"
                             "remote:FireServer(" + args + ")";
        
        exploits.push_back(exploit);
        
        // Update search position
        searchStart = match.suffix().first;
    }
    
    return exploits;
}

// Generate exploit code
std::string VulnerabilityDetector::GenerateExploitCode(const Vulnerability& vulnerability) {
    // Generate exploit code based on vulnerability type
    switch (vulnerability.m_type) {
        case VulnerabilityType::RemoteEvent:
            return "-- RemoteEvent exploit\n"
                   "local remote = game:GetService(\"ReplicatedStorage\"):FindFirstChild(\"" + 
                   vulnerability.m_name + "\", true)\n"
                   "if remote then\n"
                   "    -- Try different argument types\n"
                   "    remote:FireServer()\n"
                   "    remote:FireServer(true)\n"
                   "    remote:FireServer(1)\n"
                   "    remote:FireServer(\"string\")\n"
                   "    remote:FireServer({key = \"value\"})\n"
                   "end";
            
        case VulnerabilityType::RemoteFunction:
            return "-- RemoteFunction exploit\n"
                   "local remote = game:GetService(\"ReplicatedStorage\"):FindFirstChild(\"" + 
                   vulnerability.m_name + "\", true)\n"
                   "if remote then\n"
                   "    -- Try different argument types\n"
                   "    local result = remote:InvokeServer()\n"
                   "    print(\"Result:\", result)\n"
                   "    \n"
                   "    result = remote:InvokeServer(true)\n"
                   "    print(\"Result:\", result)\n"
                   "    \n"
                   "    result = remote:InvokeServer(1)\n"
                   "    print(\"Result:\", result)\n"
                   "    \n"
                   "    result = remote:InvokeServer(\"string\")\n"
                   "    print(\"Result:\", result)\n"
                   "    \n"
                   "    result = remote:InvokeServer({key = \"value\"})\n"
                   "    print(\"Result:\", result)\n"
                   "end";
            
        case VulnerabilityType::SecurityBypass:
            return "-- Security bypass exploit\n"
                   "-- Attempt to bypass security checks\n"
                   "local remote = game:GetService(\"ReplicatedStorage\"):FindFirstChild(\"" +
                   vulnerability.m_name + "\", true)\n"
                   "if remote then\n"
                   "    -- Try to bypass filtering\n"
                   "    remote:FireServer(\"\\255\\255\\255\")\n"
                   "    \n"
                   "    -- Try table manipulation\n"
                   "    local t = {}\n"
                   "    setmetatable(t, {__index = function() return true end})\n"
                   "    remote:FireServer(t)\n"
                   "end";
            
        case VulnerabilityType::FilterBypass:
            return "-- Filter bypass exploit\n"
                   "local remote = game:GetService(\"ReplicatedStorage\"):FindFirstChild(\"RemoteEvent\", true)\n"
                   "if remote then\n"
                   "    -- Bypass string filtering\n"
                   "    local bypass = string.char(115, 99, 114, 105, 112, 116) -- \"script\"\n"
                   "    remote:FireServer(bypass)\n"
                   "    \n"
                   "    -- Try other bypasses\n"
                   "    remote:FireServer(string.upper(\"script\"):lower())\n"
                   "    remote:FireServer({[\"s\"..\"c\"..\"r\"..\"i\"..\"p\"..\"t\"] = true})\n"
                   "end";
            
        case VulnerabilityType::ServerStorage:
            return "-- Server storage access exploit\n"
                   "-- Attempt to access server storage\n"
                   "local remote = game:GetService(\"ReplicatedStorage\"):FindFirstChild(\"RemoteFunction\", true)\n"
                   "if remote then\n"
                   "    -- Try to get server storage items\n"
                   "    local result = remote:InvokeServer(\"GetItems\")\n"
                   "    print(\"Server Storage Items:\", result)\n"
                   "    \n"
                   "    -- Try to get specific item\n"
                   "    result = remote:InvokeServer(\"GetItem\", \"" + vulnerability.m_name + "\")\n"
                   "    print(\"Item Result:\", result)\n"
                   "end";
            
        case VulnerabilityType::BackdoorScript:
            return "-- Backdoor script exploit\n"
                   "-- Attempt to execute code through backdoor\n"
                   "local remote = game:GetService(\"ReplicatedStorage\"):FindFirstChild(\"RemoteEvent\", true)\n"
                   "if remote then\n"
                   "    -- Try to execute code\n"
                   "    remote:FireServer(\"print('Backdoor working')\")\n"
                   "    \n"
                   "    -- Try more dangerous code\n"
                   "    remote:FireServer([[for i,v in pairs(game.Players:GetPlayers()) do\n"
                   "        print(v.Name)\n"
                   "    end]])\n"
                   "end";
            
        case VulnerabilityType::NetworkOwnership:
            return "-- Network ownership exploit\n"
                   "local part = workspace:FindFirstChild(\"" + vulnerability.m_name + "\", true)\n"
                   "if part and part:IsA(\"BasePart\") and not part.Anchored then\n"
                   "    -- Take control of the part\n"
                   "    part:SetNetworkOwner(game.Players.LocalPlayer)\n"
                   "    \n"
                   "    -- Manipulate the part\n"
                   "    part.Velocity = Vector3.new(0, 1000, 0) -- Launch up\n"
                   "    \n"
                   "    -- Use part for physics exploits\n"
                   "    game:GetService(\"RunService\").Heartbeat:Connect(function()\n"
                   "        if part and part.Parent then\n"
                   "            part.Velocity = Vector3.new(0, 1000, 0)\n"
                   "        end\n"
                   "    end)\n"
                   "end";
            
        case VulnerabilityType::GameSpecific:
        case VulnerabilityType::Unknown:
        default:
            return "-- Generic exploit attempt\n"
                   "-- This is a generic exploit script\n"
                   "local path = \"" + vulnerability.m_path + "\"\n"
                   "local obj = game:FindFirstChild(path, true)\n"
                   "if obj then\n"
                   "    print(\"Found target object:\", obj:GetFullName())\n"
                   "    -- Attempt to exploit\n"
                   "    if obj:IsA(\"RemoteEvent\") then\n"
                   "        obj:FireServer()\n"
                   "    elseif obj:IsA(\"RemoteFunction\") then\n"
                   "        local result = obj:InvokeServer()\n"
                   "        print(\"Result:\", result)\n"
                   "    end\n"
                   "end";
    }
}

// Update scan progress
void VulnerabilityDetector::UpdateScanProgress(float progress, const std::string& activity, uint32_t vulnerabilitiesFound) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // Update progress
    m_currentScanProgress.m_progress = progress;
    m_currentScanProgress.m_currentActivity = activity;
    m_currentScanProgress.m_vulnerabilitiesFound = vulnerabilitiesFound;
    
    // Call progress callback
    if (m_progressCallback) {
        m_progressCallback(m_currentScanProgress);
    }
}

// Add vulnerability to scan result
void VulnerabilityDetector::AddVulnerability(ScanResult& result, const Vulnerability& vulnerability) {
    // Add to result
    result.m_vulnerabilities.push_back(vulnerability);
    
    // Add to known vulnerabilities if not already known
    if (!IsKnownVulnerability(vulnerability)) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_knownVulnerabilities.push_back(vulnerability);
    }
    
    // Call detected callback
    if (m_detectedCallback) {
        m_detectedCallback(vulnerability);
    }
}

// Generate vulnerability ID
std::string VulnerabilityDetector::GenerateVulnerabilityId() {
    // Create a random UUID-like string
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 15);
    
    std::stringstream ss;
    ss << "vuln-";
    
    for (int i = 0; i < 8; ++i) {
        ss << std::hex << dis(gen);
    }
    ss << "-";
    for (int i = 0; i < 4; ++i) {
        ss << std::hex << dis(gen);
    }
    ss << "-";
    for (int i = 0; i < 4; ++i) {
        ss << std::hex << dis(gen);
    }
    ss << "-";
    for (int i = 0; i < 4; ++i) {
        ss << std::hex << dis(gen);
    }
    ss << "-";
    for (int i = 0; i < 12; ++i) {
        ss << std::hex << dis(gen);
    }
    
    return ss.str();
}

// Check if vulnerability is already known
bool VulnerabilityDetector::IsKnownVulnerability(const Vulnerability& vulnerability) {
    // Check if we already know about this vulnerability
    for (const auto& known : m_knownVulnerabilities) {
        // Consider it the same vulnerability if path and type match
        if (known.m_path == vulnerability.m_path &&
            known.m_type == vulnerability.m_type) {
            return true;
        }
    }
    
    return false;
}

// Save vulnerability database
void VulnerabilityDetector::SaveVulnerabilityDatabase() {
    try {
        // Create a JSON array for vulnerabilities
        NSMutableArray* vulnerabilitiesArray = [NSMutableArray array];
        
        for (const auto& vulnerability : m_knownVulnerabilities) {
            // Create a dictionary for this vulnerability
            NSMutableDictionary* vulnDict = [NSMutableDictionary dictionary];
            
            // Add basic properties
            [vulnDict setObject:[NSString stringWithUTF8String:vulnerability.m_id.c_str()] 
                         forKey:@"id"];
            [vulnDict setObject:[NSString stringWithUTF8String:vulnerability.m_name.c_str()] 
                         forKey:@"name"];
            [vulnDict setObject:[NSString stringWithUTF8String:vulnerability.m_description.c_str()] 
                         forKey:@"description"];
            [vulnDict setObject:[NSString stringWithUTF8String:VulnerabilityTypeToString(vulnerability.m_type).c_str()] 
                         forKey:@"type"];
            [vulnDict setObject:[NSString stringWithUTF8String:vulnerability.m_path.c_str()] 
                         forKey:@"path"];
            [vulnDict setObject:[NSString stringWithUTF8String:vulnerability.m_exploitCode.c_str()] 
                         forKey:@"exploitCode"];
            [vulnDict setObject:@(vulnerability.m_severity) 
                         forKey:@"severity"];
            [vulnDict setObject:@(vulnerability.m_reliability) 
                         forKey:@"reliability"];
            [vulnDict setObject:@(vulnerability.m_discoveryTime) 
                         forKey:@"discoveryTime"];
            [vulnDict setObject:@(vulnerability.m_verified) 
                         forKey:@"verified"];
            
            // Add tags
            NSMutableArray* tagsArray = [NSMutableArray array];
            for (const auto& tag : vulnerability.m_tags) {
                [tagsArray addObject:[NSString stringWithUTF8String:tag.c_str()]];
            }
            [vulnDict setObject:tagsArray forKey:@"tags"];
            
            // Add metadata
            NSMutableDictionary* metadataDict = [NSMutableDictionary dictionary];
            for (const auto& pair : vulnerability.m_metadata) {
                [metadataDict setObject:[NSString stringWithUTF8String:pair.second.c_str()]
                                 forKey:[NSString stringWithUTF8String:pair.first.c_str()]];
            }
            [vulnDict setObject:metadataDict forKey:@"metadata"];
            
            // Add to array
            [vulnerabilitiesArray addObject:vulnDict];
        }
        
        // Convert to JSON data
        NSError* error = nil;
        NSData* jsonData = [NSJSONSerialization dataWithJSONObject:vulnerabilitiesArray
                                                           options:NSJSONWritingPrettyPrinted
                                                             error:&error];
        
        if (error || !jsonData) {
            std::cerr << "Failed to serialize vulnerability database: " 
                     << (error ? [[error localizedDescription] UTF8String] : "Unknown error")
                     << std::endl;
            return;
        }
        
        // Get Documents directory
        NSArray* paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
        NSString* documentsDirectory = [paths objectAtIndex:0];
        
        // Create vulnerability directory if it doesn't exist
        NSString* vulnDir = [documentsDirectory stringByAppendingPathComponent:@"Vulnerabilities"];
        NSFileManager* fileManager = [NSFileManager defaultManager];
        
        if (![fileManager fileExistsAtPath:vulnDir]) {
            [fileManager createDirectoryAtPath:vulnDir
                  withIntermediateDirectories:YES
                                   attributes:nil
                                        error:&error];
            
            if (error) {
                std::cerr << "Failed to create vulnerability directory: " 
                         << [[error localizedDescription] UTF8String] << std::endl;
                return;
            }
        }
        
        // Write to file
        NSString* dbPath = [vulnDir stringByAppendingPathComponent:@"vulnerability_database.json"];
        BOOL success = [jsonData writeToFile:dbPath
                                     options:NSDataWritingAtomic
                                       error:&error];
        
        if (!success) {
            std::cerr << "Failed to write vulnerability database: " 
                     << [[error localizedDescription] UTF8String] << std::endl;
            return;
        }
        
        std::cout << "Saved vulnerability database with " << m_knownVulnerabilities.size() 
                 << " vulnerabilities" << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Exception during vulnerability database save: " << e.what() << std::endl;
    }
}

// Load vulnerability database
bool VulnerabilityDetector::LoadVulnerabilityDatabase() {
    try {
        // Get Documents directory
        NSArray* paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
        NSString* documentsDirectory = [paths objectAtIndex:0];
        
        // Get database path
        NSString* dbPath = [documentsDirectory stringByAppendingPathComponent:@"Vulnerabilities/vulnerability_database.json"];
        
        // Check if file exists
        NSFileManager* fileManager = [NSFileManager defaultManager];
        if (![fileManager fileExistsAtPath:dbPath]) {
            return false;
        }
        
        // Read file
        NSError* error = nil;
        NSData* jsonData = [NSData dataWithContentsOfFile:dbPath
                                                  options:0
                                                    error:&error];
        
        if (error || !jsonData) {
            std::cerr << "Failed to read vulnerability database: " 
                     << (error ? [[error localizedDescription] UTF8String] : "Unknown error")
                     << std::endl;
            return false;
        }
        
        // Parse JSON
        id jsonObject = [NSJSONSerialization JSONObjectWithData:jsonData
                                                        options:0
                                                          error:&error];
        
        if (error || !jsonObject || ![jsonObject isKindOfClass:[NSArray class]]) {
            std::cerr << "Failed to parse vulnerability database: " 
                     << (error ? [[error localizedDescription] UTF8String] : "Invalid format")
                     << std::endl;
            return false;
        }
        
        // Clear existing vulnerabilities
        m_knownVulnerabilities.clear();
        
        // Process vulnerabilities
        NSArray* vulnerabilitiesArray = (NSArray*)jsonObject;
        for (NSDictionary* vulnDict in vulnerabilitiesArray) {
            Vulnerability vulnerability;
            
            // Extract basic properties
            vulnerability.m_id = [[vulnDict objectForKey:@"id"] UTF8String];
            vulnerability.m_name = [[vulnDict objectForKey:@"name"] UTF8String];
            vulnerability.m_description = [[vulnDict objectForKey:@"description"] UTF8String];
            vulnerability.m_type = StringToVulnerabilityType([[vulnDict objectForKey:@"type"] UTF8String]);
            vulnerability.m_path = [[vulnDict objectForKey:@"path"] UTF8String];
            vulnerability.m_exploitCode = [[vulnDict objectForKey:@"exploitCode"] UTF8String];
            vulnerability.m_severity = [[vulnDict objectForKey:@"severity"] floatValue];
            vulnerability.m_reliability = [[vulnDict objectForKey:@"reliability"] floatValue];
            vulnerability.m_discoveryTime = [[vulnDict objectForKey:@"discoveryTime"] unsignedLongLongValue];
            vulnerability.m_verified = [[vulnDict objectForKey:@"verified"] boolValue];
            
            // Extract tags
            NSArray* tagsArray = [vulnDict objectForKey:@"tags"];
            for (NSString* tag in tagsArray) {
                vulnerability.m_tags.push_back([tag UTF8String]);
            }
            
            // Extract metadata
            NSDictionary* metadataDict = [vulnDict objectForKey:@"metadata"];
            for (NSString* key in metadataDict) {
                NSString* value = [metadataDict objectForKey:key];
                vulnerability.m_metadata[[key UTF8String]] = [value UTF8String];
            }
            
            // Add to known vulnerabilities
            m_knownVulnerabilities.push_back(vulnerability);
        }
        
        std::cout << "Loaded vulnerability database with " << m_knownVulnerabilities.size() 
                 << " vulnerabilities" << std::endl;
        
        return true;
    } catch (const std::exception& e) {
        std::cerr << "Exception during vulnerability database load: " << e.what() << std::endl;
        return false;
    }
}

// Train models with detection history
bool VulnerabilityDetector::TrainModelsWithDetectionHistory() {
    // In a real implementation, this would train the models using
    // collected vulnerability data
    
    return true;
}

// Convert vulnerability type to string
std::string VulnerabilityDetector::VulnerabilityTypeToString(VulnerabilityType type) {
    switch (type) {
        case VulnerabilityType::RemoteEvent:
            return "RemoteEvent";
        case VulnerabilityType::RemoteFunction:
            return "RemoteFunction";
        case VulnerabilityType::SecurityBypass:
            return "SecurityBypass";
        case VulnerabilityType::FilterBypass:
            return "FilterBypass";
        case VulnerabilityType::ServerStorage:
            return "ServerStorage";
        case VulnerabilityType::BackdoorScript:
            return "BackdoorScript";
        case VulnerabilityType::NetworkOwnership:
            return "NetworkOwnership";
        case VulnerabilityType::GameSpecific:
            return "GameSpecific";
        case VulnerabilityType::Unknown:
        default:
            return "Unknown";
    }
}

// Convert string to vulnerability type
VulnerabilityDetector::VulnerabilityType VulnerabilityDetector::StringToVulnerabilityType(const std::string& str) {
    if (str == "RemoteEvent") {
        return VulnerabilityType::RemoteEvent;
    } else if (str == "RemoteFunction") {
        return VulnerabilityType::RemoteFunction;
    } else if (str == "SecurityBypass") {
        return VulnerabilityType::SecurityBypass;
    } else if (str == "FilterBypass") {
        return VulnerabilityType::FilterBypass;
    } else if (str == "ServerStorage") {
        return VulnerabilityType::ServerStorage;
    } else if (str == "BackdoorScript") {
        return VulnerabilityType::BackdoorScript;
    } else if (str == "NetworkOwnership") {
        return VulnerabilityType::NetworkOwnership;
    } else if (str == "GameSpecific") {
        return VulnerabilityType::GameSpecific;
    } else {
        return VulnerabilityType::Unknown;
    }
}

} // namespace VulnerabilityDetection
} // namespace AIFeatures
} // namespace iOS
